# Smallest m such that m and reverse\(m\) each have n \(not necessarily distinct\) prime factors\.
https://oeis.org/A239697
## JSON
```JSON
[2, 4, 8, 88, 252, 2576, 8820, 2112, 4224, 8448, 44544, 48384, 846720, 4078080, 405504, 4091904, 441606144, 405909504, 886898688, 677707776, 4285005824, 63769149440, 21128282112, 633498894336, 2701312131072, 6739855589376, 29142024192, 65892155129856, 4815463645184, 445488555884544, 23088546155855872]
```
## Maple
```Maple
A239697 := proc(n)
    local a;
    for a from 1 do
        if numtheory[bigomega](a) = n then
            if numtheory[bigomega](digrev(a)) =n then
                return a;
            end if;
        end if;
    end do:
end proc: # _R. J. Mathar_, Apr 04 2014
```
## Python
```Python
import sympy
from sympy import factorint
from sympy import primorial
def Rev(x):
..rev = ''
..for i in str(x):
....rev = i + rev
..return int(rev)
def RevFact(x):
..n = 2
..while n <= primorial(x):
....if sum(list(factorint(n).values())) == x:
......if sum(list(factorint(Rev(n)).values())) == x:
........return n
......else:
........n += 1
....else:
......n += 1
x = 1
while x < 50:
..print(RevFact(x))
..x += 1
```
