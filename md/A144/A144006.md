# Triangle, read by rows of coefficients of x^n\*y^k for k\=0\.\.n\(n\-1\)/2 for n\>\=0, defined by e\.g\.f\.: A\(x,y\) \= 1 \+ Series\_Reversion\( Integral A\(\-x\*y,y\) dx \), with leading zeros in each row suppressed\.
https://oeis.org/A144006
## JSON
```JSON
[1, 1, 1, 3, -1, 15, -10, 3, -1, 105, -105, 55, -30, 10, -3, 1, 945, -1260, 910, -630, 350, -168, 76, -30, 10, -3, 1, 10395, -17325, 15750, -12880, 9135, -5789, 3381, -1806, 910, -434, 196, -76, 30, -10, 3, -1, 135135, -270270, 294525, -275275, 228375]
```
## PARI
```PARI
{T(n,k)=local(A=1+x*O(x^n)); for(i=0,n,A=1+serreverse(intformal(subst(A,x,-x*y))));n!*polcoeff(polcoeff(A,n,x),k,y)}
```
## Python
```Python
#This is only correct if the observation in the comment from 2024/08/20 is true.
def T(n,k):
    if 0 <= n <= 1:
        return 1 if k == 0 else 0
    c = {(-1,):1} #Polynomial in infinitely many variables (function iterates)
    for _ in range(n-1):
        cnext = {}
        for key, value in c.items():
            key += (0,)
            for i, ni in enumerate(key):
                term = tuple(nj-2 if j==i else nj-1 if j<=i+1 else nj
                             for j,nj in enumerate(key))
                cnext[term] = cnext.get(term,0) + value*ni
                if cnext[term] == 0:
                    del cnext[term]
        c = cnext
    pairs = {} #Reduction to single variable (evaluation at fixpoint)
    for key, value in c.items():
        s = -sum(key)
        pairs[s] = pairs.get(s,0) + value
    _, row = zip(*sorted(pairs.items())) #Coefficients
    if 0 <= k-n+1 < len(row): #Correcting number of leading 0s
        return (-1)**(n+k+1)*abs(row[k-n+1]) #Correcting signs
    else:
        return 0
# _Lucas Larsen_, Aug 22 2024
```
