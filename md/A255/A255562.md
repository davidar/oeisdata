# A reversed prime Fibonacci sequence: a\(n\+2\) is the smallest odd prime such that a\(n\) is the smallest odd prime divisor of a\(n\+1\)\+a\(n\+2\)\.
https://oeis.org/A255562
## JSON
```JSON
[3, 5, 7, 3, 11, 7, 37, 19, 277, 331, 223, 439, 7, 406507, 67, 330515394367, 967, 10576492618777, 116041, 223724392248491824062507397, 3691561, 100105207373914057144918297314160710207525630111509317, 423951181]
```
## Python
```Python
import math
def sieve(n):
    r = int(math.floor(math.sqrt(n)))
    composites = [j for i in range(2,r+1) for j in range(2*i, n, i)]
    primes = set(range(2,n)).difference(set(composites))
    return sorted(primes)
Primes = sieve(1000000)
Odd_primes = Primes[1:]
def find_smallest_odd_div(n):
    for p in Odd_primes:
        if n % p == 0:
            return p
def next_term(a,b):
    for p in Odd_primes:
        if (p + b) % a == 0:
            if find_smallest_odd_div(p+b) == a:
                return p
def compute_reversed_seq(a,b):
    seq = [a,b]
    while seq[-1] != None:
        seq.append(next_term(seq[-2],seq[-1]))
    return seq[:len(seq)-1]
print(compute_reversed_seq(3,5))
```
```Python
from sympy import isprime, factorint
from itertools import islice
def rem2(n):
    while n%2 == 0: n //= 2
    return n
def agen():
    b, c = 3, 5
    yield 3
    while True:
        yield c
        k = (c+2)//b + 1
        m = b*k
        while not isprime(m-c) or min(factorint(rem2(k)), default=b+1) < b:
            m += b
            k += 1
        b, c = c, m-c
print(list(islice(agen(), 19))) # _Michael S. Branicky_, Apr 12 2022
```
## PARI
```PARI
lista(nn) = {print1(pp=3, ", "); print1(p=5, ", "); for (n=1, nn, forprime(q=3, , s = (p+q)/ 2^(valuation(p+q, 2)); if ((s!=1) && pp == factor(s)[1,1], np = q; break);); print1(np, ", "); pp = p; p = np;);} \\ _Michel Marcus_, Jul 11 2015
```
