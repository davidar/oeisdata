# a\(1\) \= 0; thereafter, if a\(n\) has not appeared before, a\(n\+1\) \= number of existing terms which are greater than a\(n\); otherwise, a\(n\) \= n\-m where a\(m\) is the most recent copy of a\(n\)\.
https://oeis.org/A341846
## JSON
```JSON
[0, 0, 1, 0, 2, 0, 2, 2, 1, 6, 0, 5, 1, 4, 2, 7, 0, 6, 8, 0, 3, 6, 4, 9, 0, 5, 14, 0, 3, 8, 11, 1, 19, 0, 6, 13, 2, 22, 0, 5, 14, 14, 1, 11, 13, 9, 22, 9, 2, 12, 8, 21, 2, 4, 31, 0, 17, 5, 18, 5, 2, 8, 11, 19, 31, 10, 18, 8, 6, 34, 0, 15, 11, 10, 8, 7, 60, 0, 7]
```
## Mathematica
```Mathematica
Block[{nn = 120, a = {0}, c}, Do[If[IntegerQ@ c[#], AppendTo[a, i - c[#] ]; Set[c[#], i], Set[c[#], i]; AppendTo[a, Count[Most@ a, _?(# > a[[-1]] &)]]] &[ a[[-1]] ], {i, nn}]; a] (* _Michael De Vlieger_, Feb 21 2021 *)
```
## Python
```Python
def aupton(terms):
  alst, an = [], 0
  for n in range(1, terms+1):
    if an not in alst: anp1 = sum(ai > an for ai in alst)
    else: anp1 = alst[::-1].index(an) + 1
    alst, an = alst + [an], anp1
  return alst
print(aupton(79)) # _Michael S. Branicky_, Feb 21 2021
```
