# a\(0\) \= 0; for n \> 0, a\(n\) is the smallest positive integer not yet in the sequence such that the first digit of a\(n\) differs by 1 from the last digit of a\(n\-1\)\.
https://oeis.org/A341909
## JSON
```JSON
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 80, 10, 11, 20, 12, 13, 21, 22, 14, 30, 15, 40, 16, 50, 17, 60, 18, 70, 19, 81, 23, 24, 31, 25, 41, 26, 51, 27, 61, 28, 71, 29, 82, 32, 33, 42, 34, 35, 43, 44, 36, 52, 37, 62, 38, 72, 39, 83, 45, 46, 53, 47, 63, 48, 73, 49, 84, 54, 55, 64, 56, 57, 65, 66, 58, 74, 59]
```
## Mathematica
```Mathematica
Block[{a = {0}, k}, Do[k = 1; While[Nand[FreeQ[a, k], Abs[First@ IntegerDigits[k] - Mod[a[[-1]], 10]] == 1], k++]; AppendTo[a, k], {i, 76}]; a] (* _Michael De Vlieger_, Feb 23 2021 *)
```
## Python
```Python
def nextd(strn, d):
  n = int(strn) if strn != "" else 0
  return n+1 if str(n+1)[0] == str(d) else int(str(d)+'0'*len(strn))
def aupton(term):
  alst, aset = [0], {0}
  lastdstr = ["" for d in range(10)]
  for n in range(1, term+1):
    lastdig = alst[-1]%10
    firstdigs = set([max(lastdig-1, 0), min(lastdig+1, 9)]) - {0}
    cands = [nextd(lastdstr[d], d) for d in firstdigs]
    m = min(cands)
    argmin = cands.index(m)
    alst.append(m)
    strm = str(m)
    lastdstr[int(strm[0])] = strm
  return alst
print(aupton(76)) # _Michael S. Branicky_, Feb 23 2021
```
