# Least a \+ b such that a\*b \= A002110\(n\), the product of the first n primes, where a, b are positive integers\.
https://oeis.org/A182987
## JSON
```JSON
[2, 3, 5, 11, 29, 97, 347, 1429, 6229, 29873, 160879, 895681, 5448239, 34885673, 228759799, 1568299433, 11417382973, 87698582693, 684947829299, 5606539600699, 47241542381273, 403631914511993, 3587558929043927, 32684217334524347, 308342289648328511, 3036819365023723883]
```
## Mathematica
```Mathematica
a[0] = 2; a[n_] := Module[{m = Times @@ Prime[Range[n]]}, For[an = 2 Floor[Sqrt[m]] + 1, an <= m + 2, an += 2, If[IntegerQ[Sqrt[an^2 - 4 m]], Return[an]]]]; Table[an = a[n]; Print[an]; an, {n, 0, 25}] (* _Jean-FranÃ§ois Alcover_, Oct 20 2016, adapted from PARI *)
```
## PARI
```PARI
A182987(n)={if(n,vecsum(divisors(vecprod(primes(n)))[2^(n-1)..2^(n-1)+1]),2)}  \\ Needs stack size >= 2^(n+6). - _M. F. Hasler_, Sep 20 2011, edited Mar 24 2022
```
```PARI
A182987(n)={ n||return(2); my(m=prod(k=1,n,prime(k))); forstep(a=2*sqrtint(m)+1,m+2,2, issquare(a^2-4*m) & return(a)) }  \\ Slow for n >= 28, but needs not much memory. - _M. F. Hasler_, following an idea from _David Broadhurst_, Sep 20 2011
```
## Python
```Python
def A182987(n): # becomes slow for n >= 28, but not slower than memory-hungry
   # sum(divisors(primorial(n))[2**(n-1)-1:2**(n-1)+1]) if n else 2
   "Compute A182987(n) = sum of the two central divisors of primorial(n)."
   if n < 2: return n+2
   from math import isqrt # = A000196
   from sympy import primorial # = A002110
   from sympy.ntheory.primetest import is_square # = A010052
   m = primorial(n)*4; a = isqrt(m)|1  ### ceil(sqrt(m))**2 < m  for n = 26..27 !!
   while True:
      if is_square(a*a - m): return a
      a += 2
# _M. F. Hasler_, Mar 21 2022
```
