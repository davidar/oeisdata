# Numerators of positive rationals < 1 arranged by increasing sum of numerator and denominator then by increasing numerator\.
https://oeis.org/A182972
## JSON
```JSON
[1, 1, 1, 2, 1, 1, 2, 3, 1, 3, 1, 2, 4, 1, 3, 1, 2, 3, 4, 5, 1, 5, 1, 2, 3, 4, 5, 6, 1, 3, 5, 1, 2, 4, 7, 1, 3, 5, 7, 1, 2, 3, 4, 5, 6, 7, 8, 1, 5, 7, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 3, 7, 9, 1, 2, 4, 5, 8, 10, 1, 3, 5, 7, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 1, 5, 7, 11, 1, 2, 3, 4, 6, 7, 8, 9, 11, 12, 1, 3, 5, 7, 9, 11]
```
## Maple
```Maple
t1:=[];
for n from 2 to 40 do
t1:=[op(t1),1/(n-1)];
for i from 2 to floor((n-1)/2) do
   if gcd(i,n-i)=1 then t1:=[op(t1),i/(n-i)]; fi; od:
od:
t1;
```
## Mathematica
```Mathematica
t1={}; For[n=2, n <= 40, n++, AppendTo[t1, 1/(n-1)]; For[i=2, i <= Floor[(n-1)/2], i++, If[GCD[i, n-i] == 1, AppendTo[t1, i/(n-i)]]]]; t1 // Numerator // Rest (* _Jean-FranÃ§ois Alcover_, Jan 20 2015, translated from Maple *)
```
## Pascal
```Pascal
program a182972;
var
  num,den,n: longint;
function gcd(i,j: longint):longint;
begin
  repeat
    if i>j then i:=i mod j else j:=j mod i;
  until (i=0) or (j=0);
  if i=0 then gcd:=j else gcd:=i;
end;
begin
  num:=1; den:=1; n:=0;
  repeat
    repeat
      inc(num); dec(den);
      if num>=den then
      begin
        inc(den,num); num:=1;
      end;
    until gcd(num,den)=1;
    inc(n); writeln(n,' ',num);
  until n=100000;
end.
```
## Haskell
```Haskell
a182972 n = a182972_list !! (n-1)
a182972_list = map fst $ concatMap q [3..] where
   q x = [(num, den) | num <- [1 .. div x 2],
                       let den = x - num, gcd num den == 1]
-- _Reinhard Zumkeller_, Jul 29 2014
```
## Python
```Python
from itertools import count, islice
from math import gcd
def A182972_gen(): # generator of terms
    return (i for n in count(2) for i in range(1,1+(n-1>>1)) if gcd(i,n-i)==1)
A182972_list = list(islice(A182972_gen(),10)) # _Chai Wah Wu_, Aug 28 2023
```
