# Number of weakly connected digraphs with n unlabeled nodes\.
https://oeis.org/A003085
## JSON
```JSON
[1, 2, 13, 199, 9364, 1530843, 880471142, 1792473955306, 13026161682466252, 341247400399400765678, 32522568098548115377595264, 11366712907233351006127136886487, 14669074325902449468573755897547924182]
```
## Maple
```Maple
# The function EulerInvTransform is defined in A358451.
a := EulerInvTransform(A000273):
seq(a(n), n = 1..13); # _Peter Luschny_, Nov 21 2022
```
## Mathematica
```Mathematica
Needs["Combinatorica`"]; d[n_] := GraphPolynomial[n, x, Directed] /. x -> 1; max = 13; se = Series[ Sum[a[n]*x^n/n, {n, 1, max}] - Log[1 + Sum[ d[n]*x^n, {n, 1, max}]], {x, 0, max}]; sol = SolveAlways[ se == 0, x]; Do[ A003084[n] = a[n] /. sol[[1]], {n, 1, max}]; ClearAll[a, d]; a[n_] := (1/n)*Sum[ MoebiusMu[ n/d ] * A003084[d], {d, Divisors[n]} ]; Table[ a[n], {n, 1, max}] (* _Jean-François Alcover_, Feb 01 2012, after formula *)
```
```Mathematica
terms = 13;
```
```Mathematica
permcount[v_] := Module[{m = 1, s = 0, k = 0, t}, For[i = 1, i <= Length[v], i++, t = v[[i]]; k = If[i > 1 && t == v[[i - 1]], k + 1, 1]; m *= t*k; s += t]; s!/m];
```
```Mathematica
edges[v_] := Sum[2*GCD[v[[i]], v[[j]]], {i, 2, Length[v]}, {j, 1, i - 1}] + Total[v - 1];
```
```Mathematica
d[n_] := (s = 0; Do[s += permcount[p]*2^edges[p], {p, IntegerPartitions[n]} ]; s/n!);
```
```Mathematica
A003084 = CoefficientList[Log[Sum[d[n] x^n, {n, 0, terms+1}]] + O[x]^(terms + 1), x] Range[0, terms] // Rest;
```
```Mathematica
a[n_] := (1/n)*Sum[MoebiusMu[n/d] * A003084[[d]], {d, Divisors[n]}];
```
```Mathematica
Table[a[n], {n, 1, terms}] (* _Jean-François Alcover_, Aug 30 2019, after _Andrew Howroyd_ in A003084 *)
```
## Python
```Python
from functools import lru_cache
from itertools import product, combinations
from fractions import Fraction
from math import prod, gcd, factorial
from sympy import mobius, divisors
from sympy.utilities.iterables import partitions
def A003085(n):
    @lru_cache(maxsize=None)
    def b(n): return int(sum(Fraction(1<<sum(p[r]*p[s]*gcd(r,s)<<1 for r,s in combinations(p.keys(),2))+sum(r*(q*r-1) for q, r in p.items()),prod(q**r*factorial(r) for q, r in p.items())) for p in partitions(n)))
    @lru_cache(maxsize=None)
    def c(n): return n*b(n)-sum(c(k)*b(n-k) for k in range(1,n))
    return sum(mobius(n//d)*c(d) for d in divisors(n,generator=True))//n # _Chai Wah Wu_, Jul 05 2024
```
