# Numbers n such that in a rotated\-square spiral with positive integers \(A215468\) among n's eight nearest neighbors five or more are primes\.
https://oeis.org/A215471
## JSON
```JSON
[8, 30, 138, 658, 2620, 3010, 3168, 3372, 3462, 8628, 11940, 17682, 24918, 27918, 32560, 39228, 39790, 40128, 43608, 48532, 53268, 55372, 56040, 56712, 73362, 85200, 85888, 90646, 96052, 101748, 102652, 104382, 112068, 113932, 115330, 119298, 128518, 129288, 131500]
```
## Python
```Python
SIZE = 3335  # must be odd
TOP = SIZE*SIZE
t = TOP//2
prime = [1]*t
prime[1]=0
for i in range(4,t,2):
    prime[i]=0
for i in range(3,t,2):
    if prime[i]==1:
        for j in range(i*3,t,i*2):
            prime[j]=0
grid = [0] * TOP
posX = posY = SIZE//2
saveX = [0]* (t+1)
saveY = [0]* (t+1)
grid[posY*SIZE+posX] = 1
saveX[1]=posX
saveY[1]=posY
posX += 1
grid[posY*SIZE+posX] = 2
saveX[2]=posX
saveY[2]=posY
n = 3
def walk(stepX, stepY, chkX, chkY):
  global posX, posY, n
  while 1:
    posX+=stepX
    posY+=stepY
    grid[posY*SIZE+posX]=n
    saveX[n]=posX
    saveY[n]=posY
    n+=1
    if grid[(posY+chkY)*SIZE+posX+chkX]==0:
        return
while posX!=SIZE-1:
    walk(-1,  1, -1, -1)    # down-left
    walk(-1, -1,  1, -1)    # up-left
    walk( 1, -1,  1,  0)    # up-right
    walk( 1,  0,  1,  1)    # right
    walk( 1,  1, -1,  1)    # down-right
for s in range(1, n):
    posX = saveX[s]
    posY = saveY[s]
    a,b=(grid[(posY-1)*SIZE+posX-1]) , (grid[(posY-1)*SIZE+posX+1])
    c,d=(grid[(posY+1)*SIZE+posX-1]) , (grid[(posY+1)*SIZE+posX+1])
    e,f=(grid[(posY-1)*SIZE+posX  ]) , (grid[(posY+1)*SIZE+posX  ])
    g,h=(grid[ posY   *SIZE+posX-1]) , (grid[ posY   *SIZE+posX+1])
    if a*b==0 or c*d==0 or e*f==0 or g*h==0:
        break
    z = prime[a]+prime[b]+prime[c]+prime[d]
    if z+prime[e]+prime[f]+prime[g]+prime[h] >= 5:
        print s,
```
