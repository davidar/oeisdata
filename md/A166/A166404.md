# Self\-inverse permutation of natural numbers obtained by exchanging the run lengths of adjacent runs of ones and zeros in the binary expansion of n, starting from the most significant run of 1's\. \(See the example lines\)\.
https://oeis.org/A166404
## JSON
```JSON
[0, 1, 2, 3, 6, 5, 4, 7, 14, 13, 10, 11, 12, 9, 8, 15, 30, 29, 26, 27, 22, 21, 20, 23, 28, 25, 18, 19, 24, 17, 16, 31, 62, 61, 58, 59, 54, 53, 52, 55, 46, 45, 42, 43, 44, 41, 40, 47, 60, 57, 50, 51, 38, 37, 36, 39, 56, 49, 34, 35, 48, 33, 32, 63, 126, 125, 122, 123, 118, 117]
```
## Scheme
```Scheme
(define (A166404 n) (let ((runlens (binexp->runcount1list n))) (runcount1list->binexp (interleave (bisect runlens 1) (bisect runlens 0)))))
(define (binexp->runcount1list n) (if (zero? n) (list) (let loop ((n n) (rc (list)) (count 0) (prev-bit (modulo n 2))) (if (zero? n) (cons count rc) (if (eq? (modulo n 2) prev-bit) (loop (floor->exact (/ n 2)) rc (1+ count) (modulo n 2)) (loop (floor->exact (/ n 2)) (cons count rc) 1 (modulo n 2)))))))
(define (runcount1list->binexp lista) (let loop ((lista lista) (s 0) (state 1)) (cond ((null? lista) s) (else (loop (cdr lista) (+ (* s (expt 2 (car lista))) (* state (- (expt 2 (car lista)) 1))) (- 1 state))))))
(define (bisect lista parity) (let loop ((lista lista) (i 0) (z (list))) (cond ((null? lista) (reverse! z)) ((eq? i parity) (loop (cdr lista) (modulo (1+ i) 2) (cons (car lista) z))) (else (loop (cdr lista) (modulo (1+ i) 2) z)))))
(define (interleave a b) (let loop ((z (list)) (a a) (b b)) (cond ((and (null? a) (null? b)) (reverse! z)) ((null? a) (loop (cons (car b) z) a (cdr b))) ((null? b) (loop (cons (car a) z) (cdr a) b)) (else (loop (cons (car b) (cons (car a) z)) (cdr a) (cdr b))))))
```
## Python
```Python
def a(n):
    if n==0: return 0
    x=bin(n)[2:]
    r=[]
    s=1
    p=""
    for i in range(1, len(x)):
        if x[i - 1]==x[i]: s+=1
        else:
            r+=[s, ]
            s=1
    l=r+[s]
    L=[]
    if len(l)%2==0:
        for i in range(0, len(l), 2): L+=[l[i + 1], l[i]]
    else:
        b=l[-1]
        for i in range(0, len(l) - 1, 2): L+=[l[i + 1], l[i]]
        L+=[b, ]
    for i in range(len(L)):
        if i%2==0: p+='1'*L[i]
        else: p+='0'*L[i]
    return int(p, 2)
print([a(n) for n in range(101)]) # _Indranil Ghosh_, Jun 12 2017
```
