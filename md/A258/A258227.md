# Concatenate the natural numbers, then partition into minimal strings so that adjacent terms have a common divisor greater than 1\.
https://oeis.org/A258227
## JSON
```JSON
[12, 3, 45, 6, 78, 9, 1011, 12, 1314, 15, 1617, 18, 192, 0, 2, 12, 2, 2, 32, 4, 2, 52, 6, 2, 72, 8, 2, 930, 3, 132, 3, 3, 3, 435, 3, 6, 3, 738, 3, 9, 4041, 42, 4, 34, 4, 4, 54, 6, 4, 74, 8, 4, 950, 5, 15, 25, 35, 45, 5, 5, 65, 75, 85, 960, 6, 16, 2, 6, 3, 6]
```
## Haskell
```Haskell
a258227 n = a258227_list !! (n-1)
a258227_list = f 12 1 (map toInteger $ tail a007376_list) where
   f x y (d:ds) | gcd x y > 1 = y : f y d ds
                | otherwise   = f x (10 * y + d) ds
```
## Python
```Python
from math import gcd
from itertools import count
def diggen():
    for k in count(1): yield from list(map(int, str(k)))
def aupton(terms):
    g = diggen()
    alst, aset = [12], {12}
    _, _, nxtd, nxtnxtd = next(g), next(g), next(g), next(g)
    for n in range(2, terms+1):
        an, nxtd, nxtnxtd = nxtd, nxtnxtd, next(g)
        while gcd(an, alst[-1]) == 1 or nxtd == nxtnxtd == 0:
            an, nxtd, nxtnxtd = int(str(an) + str(nxtd)), nxtnxtd, next(g)
        alst.append(an); aset.add(an)
    return alst
print(aupton(70)) # _Michael S. Branicky_, Dec 03 2021
```
