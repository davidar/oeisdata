# a\(1\) \= 1; thereafter a\(n\) is always the smallest integer \> a\(n\-1\) not leading to a contradiction, such that the concatenation of any two consecutive digits in the sequence is a prime\.
https://oeis.org/A152607
## JSON
```JSON
[1, 3, 7, 9, 71, 73, 79, 711, 713, 717, 971, 973, 1111, 1113, 1117, 1119, 7111, 7113, 7117, 9711, 9713, 11111, 11113, 11117, 11119, 71111, 71113, 71117, 97111, 97113, 111111, 111113, 111117, 111119, 711111, 711113, 711117, 971111]
```
## Python
```Python
from itertools import count, islice
def cgen(seed, digits, geq="0"): # numbers satisfying the condition
    allowed = {"1": "1379", "3": "17", "7": "139", "9": "7"}
    if digits == 1:
        yield from (c for c in allowed[seed] if c >= geq); return
    for f in (c for c in allowed[seed] if c >= geq):
        yield from (f + r for r in cgen(f, digits-1))
def nextc(k): # next element of cgen greater than k
    s = str(k)
    for d in count(len(s)):
        geq = s[0] if d == len(s) else "0"
        for c in map(int, cgen(s[-1], d, geq=geq)):
            if c > k: return c
def agen():
    an = 1
    for n in count(1): yield an; an = nextc(an)
print(list(islice(agen(), 40))) # _Michael S. Branicky_, Jul 12 2022
```
```Python
# alternate using pattern from comments
from itertools import count, islice
def agen():
    yield from [1, 3, 7, 9, 71, 73, 79, 711, 713, 717, 971]
    for i in count(0):
        i1 = "1"*i
        yield from map(int, ("97"+i1+"3", i1+"1111", i1+"1113", i1+"1117", i1+"1119", "7111"+i1, "711"+i1+"3", "711"+i1+"7", "9711"+i1))
print(list(islice(agen(), 40))) # _Michael S. Branicky_, Jul 12 2022
```
