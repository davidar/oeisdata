# Number of theorems in the MIU formal system which can be proved in n steps or fewer starting with the axiom 'mi'\.
https://oeis.org/A331536
## JSON
```JSON
[1, 3, 6, 11, 25, 69, 282, 1730, 15885, 210105, 3986987, 106053474]
```
## Mathematica
```Mathematica
MIURules = {StartOfString ~~ x : ___ ~~ "I" ~~ EndOfString :> x <> "IU", StartOfString ~~ "M" ~~ x : ___ ~~ EndOfString :> "M" <> x <> x, "III" :> "U", "UU" :> ""}; (*The rules of the MIU formal system*)
```
```Mathematica
MIUNext[s_String, rule_Integer] :=StringReplaceList[s, MIURules[[rule]]]
```
```Mathematica
g[x_]:=DeleteDuplicates[Flatten[Join[{x},Table[Table[MIUNext[x[[j]],n], {n, 1, 4}],{j, 1,Length[x]}]]]]
```
```Mathematica
a[n_Integer]:=Nest[g, "MI", n] // Length (*a[n] gives the number of theorems that can be proved in  n steps or fewer.  A331536[n]=a[n]. Remove //Length if you wish to see the theorems being counted.*)
```
```Mathematica
(* _Brian Tenneson_, Sep 21 2023 *)
```
## Python
```Python
def occurrence_swaps(w, s, t):
  out, oi = [], w.find(s)
  while oi != -1:
    out.append(w[:oi] + t + w[oi+len(s):])
    oi = w.find(s, oi+1)
  return out
def moves(w): # moves for word w in miu system
  nxt = [w + w] # Rule 2 ('m' not stored; else use nxt = [w + w[1:]])
  if w[-1] == 'i': nxt.append(w + 'u')       # Rule 1
  nxt.extend(occurrence_swaps(w, 'iii', 'u')) # Rule 3
  nxt.extend(occurrence_swaps(w, 'uu', ''))   # Rule 4
  return nxt
def alst(maxd=float('inf'), v=False):
  alst, d = [], 0
  reached, frontier = {'i'}, {'i'} # don't store 'm's (else use 'mi' twice)
  alst.append(len(reached))
  if v: print(len(reached), end=", ")
  while len(frontier) > 0 and d < maxd:
    reach1 = set(m for p in frontier for m in moves(p) if m not in reached)
    if v: print(len(reached)+len(reach1), end=", ")
    alst.append(len(reached)+len(reach1))
    reached |= reach1
    frontier = reach1
    d += 1
  return alst
alst(maxd=10, v=True) # _Michael S. Branicky_, Dec 29 2020
```
