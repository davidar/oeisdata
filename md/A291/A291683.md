# Number of permutations p of \[n\] such that in 0p the largest up\-jump equals 2 and no down\-jump is larger than 2\.
https://oeis.org/A291683
## JSON
```JSON
[0, 0, 1, 3, 9, 25, 71, 205, 607, 1833, 5635, 17577, 55515, 177191, 570699, 1852571, 6055079, 19910729, 65823751, 218654099, 729459551, 2443051213, 8210993363, 27685671843, 93625082139, 317470233149, 1079183930827, 3676951654519, 12554734605495, 42952566314235]
```
## Maple
```Maple
b:= proc(u, o, k) option remember; `if`(u+o=0, 1,
      add(b(u-j, o+j-1, k), j=1..min(2, u))+
      add(b(u+j-1, o-j, k), j=1..min(k, o)))
    end:
a:= n-> b(0, n, 2)-b(0, n, 1):
seq(a(n), n=0..30);
```
## Mathematica
```Mathematica
b[u_, o_, k_] := b[u, o, k] = If[u + o == 0, 1, Sum[b[u - j, o + j - 1, k], {j, 1, Min[2, u]}] + Sum[b[u + j - 1, o - j, k], {j, 1, Min[k, o]}]];
```
```Mathematica
a[n_] := b[0, n, 2] - b[0, n, 1];
```
```Mathematica
Array[a, 30, 0] (* _Jean-Fran√ßois Alcover_, May 31 2019, from Maple *)
```
## Python
```Python
from sympy.core.cache import cacheit
@cacheit
def b(u, o, k): return 1 if u + o==0 else sum([b(u - j, o + j - 1, k) for j in range(1, min(2, u) + 1)]) + sum([b(u + j - 1, o - j, k) for j in range(1, min(k, o) + 1)])
def a(n): return b(0, n, 2) - b(0, n, 1)
for n in range(31): print (a(n)) # _Indranil Ghosh_, Aug 30 2017
```
