# Practical numbers: positive integers m such that every k <\= sigma\(m\) is a sum of distinct divisors of m\. Also called panarithmic numbers\.
https://oeis.org/A005153
## JSON
```JSON
[1, 2, 4, 6, 8, 12, 16, 18, 20, 24, 28, 30, 32, 36, 40, 42, 48, 54, 56, 60, 64, 66, 72, 78, 80, 84, 88, 90, 96, 100, 104, 108, 112, 120, 126, 128, 132, 140, 144, 150, 156, 160, 162, 168, 176, 180, 192, 196, 198, 200, 204, 208, 210, 216, 220, 224, 228, 234, 240, 252]
```
## Maple
```Maple
isA005153 := proc(n)
    local ifs,pprod,p,i ;
    if n = 1 then
        return true;
    elif type(n,'odd') then
        return false ;
    end if;
    # not using ifactors here directly because no guarantee primes are sorted...
    ifs := ifactors(n)[2] ;
    pprod := 1;
    for p in sort(numtheory[factorset](n) ) do
        for i in ifs do
            if op(1,i) = p then
                if p > 2 and p > 1+numtheory[sigma](pprod) then
                    return false ;
                end if;
                pprod := pprod*p^op(2,i) ;
            end if;
        end do:
    end do:
    return true ;
end proc:
for n from 1 to 300 do
    if isA005153(n)  then
        printf("%d,",n) ;
    end if;
end do: # _R. J. Mathar_, Jul 07 2023
```
## Mathematica
```Mathematica
PracticalQ[n_] := Module[{f,p,e,prod=1,ok=True}, If[n<1 || (n>1 && OddQ[n]), False, If[n==1, True, f=FactorInteger[n]; {p,e} = Transpose[f]; Do[If[p[[i]] > 1+DivisorSigma[1,prod], ok=False; Break[]]; prod=prod*p[[i]]^e[[i]], {i,Length[p]}]; ok]]]; Select[Range[200], PracticalQ] (* _T. D. Noe_, Apr 02 2010 *)
```
## Haskell
```Haskell
a005153 n = a005153_list !! (n-1)
a005153_list = filter (\x -> all (p $ a027750_row x) [1..x]) [1..]
   where p _  0 = True
         p [] _ = False
         p ds'@(d:ds) m = d <= m && (p ds (m - d) || p ds m)
-- _Reinhard Zumkeller_, Feb 23 2014, Oct 27 2011
```
## PARI
```PARI
is_A005153(n)=bittest(n,0) && return(n==1); my(P=1); n && !for(i=2,#n=factor(n)~,n[1,i]>1+(P*=sigma(n[1,i-1]^n[2,i-1])) && return) \\ _M. F. Hasler_, Jan 13 2013
```
## Python
```Python
from sympy import factorint
def is_A005153(n):
    if n & 1: return n == 1
    f = factorint(n) ; P = (2 << f.pop(2)) - 1
    for p in f: # factorint must have prime factors in increasing order
        if p > 1 + P: return
        P *= p**(f[p]+1)//(p-1)
    return True # _M. F. Hasler_, Jan 02 2023
```
```Python
from sympy import divisors;from more_itertools import powerset
[i for i in range(1,253) if (lambda x:len(set(map(sum,powerset(x))))>sum(x))(divisors(i))] # _Nicholas Stefan Georgescu_, May 20 2023
```
