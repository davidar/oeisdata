# Hofstadter Q\-sequence: a\(1\) \= a\(2\) \= 1; a\(n\) \= a\(n\-a\(n\-1\)\) \+ a\(n\-a\(n\-2\)\) for n \> 2\.
https://oeis.org/A005185
## JSON
```JSON
[1, 1, 2, 3, 3, 4, 5, 5, 6, 6, 6, 8, 8, 8, 10, 9, 10, 11, 11, 12, 12, 12, 12, 16, 14, 14, 16, 16, 16, 16, 20, 17, 17, 20, 21, 19, 20, 22, 21, 22, 23, 23, 24, 24, 24, 24, 24, 32, 24, 25, 30, 28, 26, 30, 30, 28, 32, 30, 32, 32, 32, 32, 40, 33, 31, 38, 35, 33, 39, 40, 37, 38, 40, 39]
```
## Maple
```Maple
A005185 := proc(n) option remember;
    if n<=2 then 1
    elif n > procname(n-1) and n > procname(n-2) then
        RETURN(procname(n-procname(n-1))+procname(n-procname(n-2)));
    else
        ERROR(" died at n= ", n);
    fi; end proc;
# More generally, the following defines the Hofstadter-Huber sequence Q(r,s) - _N. J. A. Sloane_, Apr 15 2014
r:=1; s:=2;
a:=proc(n) option remember; global r,s;
if n <= s then  1
else
    if (a(n-r) <= n) and (a(n-s) <= n) then
    a(n-a(n-r))+a(n-a(n-s));
    else lprint("died with n =",n); return (-1);
    fi; fi; end;
[seq(a(n), n=1..100)];
```
## Mathematica
```Mathematica
a[1]=a[2]=1; a[n_]:= a[n]= a[n -a[n-1]] + a[n -a[n-2]]; Table[ a[n], {n,70}]
```
## Scheme
```Scheme
: (define q (lambda (n) (cond ( (eqv? n 0) 1) ( (eqv? n 1) 1) ( #t (+ (q (- n (q (- n 1)))) (q (- n (q (- n 2)))))))))
```
```Scheme
;; An implementation of memoization-macro definec can be found for example in: http://oeis.org/wiki/Memoization
(definec (A005185 n) (if (<= n 2) 1 (+ (A005185 (- n (A005185 (- n 1)))) (A005185 (- n (A005185 (- n 2)))))))
;; _Antti Karttunen_, Mar 22 2017
```
## MuPAD
```MuPAD
q:=proc(n) option remember; begin if n<=2 then 1 else q(n-q(n-1))+q(n-q(n-2)) end_if; end_proc: q(i)$i=1..100; // _Zerinvary Lajos_, Apr 03 2007
```
## PARI
```PARI
{a(n)= local(A); if(n<1, 0, A=vector(n,k,1); for(k=3, n, A[k]= A[k-A[k-1]]+ A[k-A[k-2]]); A[n])} /* _Michael Somos_, Jul 16 2007 */
```
## Haskell
```Haskell
a005185 n = a005185_list !! (n-1)
a005185_list = 1 : 1 : zipWith (+)
   (map a005185 $ zipWith (-) [3..] a005185_list)
   (map a005185 $ zipWith (-) [3..] $ tail a005185_list)
-- _Reinhard Zumkeller_, Jun 02 2013, Sep 15 2011
```
## C
```C
#include <stdio.h>
#define LIM 20
int Qa[LIM];
int Q(int n){if (n==1 || n==2){return 1;} else{return Qa[n-Qa[n-1]]+Qa[n-Qa[n-2]];}}
int main(){int i;printf("n\tQ\n");for(i=1; i<LIM; i+=1){printf("%d\t%d\n", i, Q(i));Qa[i]=Q(i);}printf("\n");} // _Gonzalo Ciruelos_, Aug 01 2013
```
## Magma
```Magma
I:=[1,1]; [n le 2 select I[n] else Self(n-Self(n-1))+Self(n-Self(n-2)): n in [1..90]]; // _Vincenzo Librandi_, Aug 08 2014
```
## Sage
```Sage
@CachedFunction
def a(n):
    if (n<3): return 1
    else: return a(n -a(n-1)) + a(n -a(n-2))
[a(n) for n in (1..70)] # _G. C. Greubel_, Feb 13 2020
```
## Python
```Python
from functools import lru_cache
@lru_cache(maxsize=None)
def a(n):
    if n < 3: return 1
    return a(n - a(n-1)) + a(n - a(n-2))
print([a(n) for n in range(1, 75)]) # _Michael S. Branicky_, Jul 26 2021
```
