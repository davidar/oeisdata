# Consider the aliquot parts, in ascending order, of a composite number\. Take their sum and repeat the process deleting the minimum number and adding the previous sum\. The sequence lists the numbers that after some iterations reach a sum equal to the reverse of themselves\.
https://oeis.org/A247012
## JSON
```JSON
[6, 133, 172, 841, 1005, 1603, 4258, 5299, 192901, 498906, 1633303, 5307589, 16333303, 20671542, 41673714, 42999958, 73687923]
```
## Maple
```Maple
with(numtheory): R:=proc(w) local x,y; x:=w; y:=0;
while x>0 do y:=10*y+(x mod 10); x:=trunc(x/10); od: y; end:
P:=proc(q,h) local a,b,c,k,n,t,v; v:=array(1..h);
for n from 2 to q do if not isprime(n) then
a:=sort([op(divisors(n))]); b:=nops(a)-1; c:=ilog10(n)+1;
for k from 1 to b do v[k]:=a[k]; od;
t:=b+1; v[t]:=add(v[k], k=1..b);
if R(v[t])=n then print(n); else
while ilog10(v[t])+1<=c do t:=t+1; v[t]:=add(v[k], k=t-b..t-1);
if R(v[t])=n then print(n); break; fi; od; fi; fi; od;
end: P(10^9, 1000);
```
## Mathematica
```Mathematica
A247012 = {};
```
```Mathematica
For[n = 4, n <= 1000000, n++,
```
```Mathematica
 If[PrimeQ[n], Continue[]];
```
```Mathematica
 r = IntegerReverse[n];
```
```Mathematica
 a = Most[Divisors[n]];
```
```Mathematica
 sum = Total[a];
```
```Mathematica
 While[sum < r, sum = Total[a = Join[Rest[a], {sum}]]];
```
```Mathematica
 If[sum == r, AppendTo[A247012, n]];
```
```Mathematica
]; A247012 (* _Robert Price_, Sep 08 2019 *)
```
## Python
```Python
from sympy import isprime, divisors
A247012_list = []
for n in range(2,10**9):
....m = int(str(n)[::-1])
....if not isprime(n):
........x = divisors(n)
........x.pop()
........y = sum(x)
........while y < m:
............x, y = x[1:]+[y], 2*y-x[0]
........if y == m:
............A247012_list.append(n) # _Chai Wah Wu_, Sep 12 2014
```
