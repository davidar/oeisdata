# Number of n\-digit primes that consist of at least n\-1 copies of some decimal digit\.
https://oeis.org/A266149
## JSON
```JSON
[4, 21, 46, 43, 40, 53, 35, 49, 40, 38, 44, 52, 35, 45, 49, 42, 38, 57, 28, 45, 38, 47, 38, 52, 33, 45, 56, 38, 36, 65, 29, 56, 48, 40, 38, 58, 37, 33, 57, 40, 37, 61, 41, 39, 37, 44, 36, 55, 47, 43, 47, 43, 35, 62, 43, 46, 29, 35, 37, 56, 39, 41, 46, 48, 39, 74, 45, 34, 34, 35, 34, 67, 39, 45, 43]
```
## Mathematica
```Mathematica
Length /@ Array[Function[n, Select[Union[Flatten[Function[k, Select[FromDigits /@ Flatten[Permutations[Flatten@ {Table[k, {n - 1}], #}] & /@ Range[0, 9], 1], PrimeQ]] /@ Range[1, 9]]], Function[m, IntegerLength@ m == n]]], 100] (* _Michael De Vlieger_, Jan 01 2016 *)
```
## Python
```Python
from sympy import isprime
def a(n):
  if n == 1: return 4
  okset = set()
  for digit1 in "24568":
    for digit2 in "1379":
      t = int(digit1*(n-1) + digit2)
      if isprime(t): okset.add(t)
  for digit1 in "1379":
    for digit2 in "0123456789":
      if ((n-1)*int(digit1) + int(digit2))%3 == 0: continue
      for j in range(n):
        mc = digit1*j + digit2 + digit1*(n-1-j)
        if mc[0] == '0': continue
        t = int(mc)
        if isprime(t): okset.add(t)
  return len(okset)
print([a(n) for n in range(1, 76)]) # _Michael S. Branicky_, Apr 21 2021
```
