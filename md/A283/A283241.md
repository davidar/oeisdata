# Triangle read by rows: S\(n,k\) \= total number of directed self\-avoiding walks \(SAWs\) of length k in an n\-ladder graph\.
https://oeis.org/A283241
## JSON
```JSON
[2, 2, 4, 8, 8, 8, 6, 14, 20, 28, 20, 16, 8, 20, 32, 52, 56, 64, 40, 28, 10, 26, 44, 76, 96, 132, 128, 128, 72, 44, 12, 32, 56, 100, 136, 204, 240, 296, 264, 232, 120, 64, 14, 38, 68, 124, 176, 276, 356, 492, 548, 608, 504, 392, 188, 88]
```
## Python
```Python
# As A283240 but Tnk initialized as grid instead of a triangle
maxN=20
Tnk=[[0 for column in range(0, maxN*2)] for row in range(0, maxN+1)]
Tnk[1][0]=2 # initial values for the special case of 1-ladder.  Two single nodes.
Tnk[1][1]=2 # SAW of length 1 on a L_1, either left or right
for row in range(2, maxN+1):
    for column in range(0, row*2):
        if(column+1 < row):
            # path is smaller than ladder - no possible SAW using all rows
            Tnk[row][column] = 0
        elif(column+1 == row):
            # vertical SAW, 2 possible in 2 directions
            Tnk[row][column] = 4
        elif(column == row*2 -1):
            # n-ladder Hamiltonian A137882
            Tnk[row][column] = 2*(row*row - row + 2)
        elif(column == 2*(row-1)):
            # Grow SAW including Hamiltonians from previous row, 4 extra SAWs from Hamiltonians
            Tnk[row][column] = Tnk[row-1][column-1] + Tnk[row-1][column-2] + 4
        else:
            # Grow SAW from previous SAWs. Either adding one or two edges
            Tnk[row][column] = Tnk[row-1][column-1] + Tnk[row-1][column-2]
# Sum multiples of the columns above this one e.g. T(n,k) + 2T(n,k-1) + 3T(n,k-2) + ...
Snk=[[0 for column in range(0,row*2)] for row in range(0,maxN+1)]
for row in range(1,maxN+1):
    for column in range(0,(row*2)):
        for i in range(0,row):
            Snk[row][column]+=(i+1)*Tnk[row-i][column]
print(Snk)
```
