# Kalmár's \[Kalmar's\] problem: number of ordered factorizations of n\.
https://oeis.org/A074206
## JSON
```JSON
[0, 1, 1, 1, 2, 1, 3, 1, 4, 2, 3, 1, 8, 1, 3, 3, 8, 1, 8, 1, 8, 3, 3, 1, 20, 2, 3, 4, 8, 1, 13, 1, 16, 3, 3, 3, 26, 1, 3, 3, 20, 1, 13, 1, 8, 8, 3, 1, 48, 2, 8, 3, 8, 1, 20, 3, 20, 3, 3, 1, 44, 1, 3, 8, 32, 3, 13, 1, 8, 3, 13, 1, 76, 1, 3, 8, 8, 3, 13, 1, 48, 8, 3, 1, 44, 3, 3, 3, 20, 1, 44, 3, 8, 3, 3, 3, 112]
```
## Maple
```Maple
a := array(1..150): for k from 1 to 150 do a[k] := 0 od: a[1] := 1: for j from 2 to 150 do for m from 1 to j-1 do if j mod m = 0 then a[j] := a[j]+a[m] fi: od: od: for k from 1 to 150 do printf(`%d,`,a[k]) od: # _James A. Sellers_, Dec 07 2000
A074206:= proc(n) option remember; if n > 1 then `+`(op(apply(A074206, numtheory[divisors](n)[1..-2]))) else n fi end: # _M. F. Hasler_, Oct 12 2018
```
## Mathematica
```Mathematica
a[0] = 0; a[1] = 1; a[n_] := a[n] = a /@ Most[Divisors[n]] // Total; a /@ Range[20000] (* _N. J. A. Sloane_, May 04 2016, based on program in A002033 *)
```
```Mathematica
ccc[n_]:=Switch[n,0,{},1,{{1}},_,Join@@Table[Prepend[#,n]&/@ccc[d],{d,Most[Divisors[n]]}]]; Table[Length[ccc[n]],{n,0,100}] (* _Gus Wiseman_, Aug 25 2020 *)
```
## Haskell
```Haskell
a074206 n | n <= 1 = n
| otherwise = 1 + (sum $ map (a074206 . (div n)) $
tail $ a027751_row n)
-- _Reinhard Zumkeller_, Oct 01 2012
```
## PARI
```PARI
A=vector(100);A[1]=1; for(n=2,#A,A[n]=1+sumdiv(n,d,A[d])); A/=2; A[1]=1; concat(0,A) \\ _Charles R Greathouse IV_, Nov 20 2012
```
```PARI
{a(n) = if( n<2, n>0, my(A = divisors(n)); sum(k=1, #A-1, a(A[k])))}; /* _Michael Somos_, Dec 26 2016 */
```
```PARI
A074206(n)=if(n>1, sumdiv(n, i, if(i<n, A074206(i))),n) \\ _M. F. Hasler_, Oct 12 2018
```
```PARI
A74206=[1]; A074206(n)={if(#A74206<n, A74206=concat(A74206,vector(n*3\/2-#A74206)), n&& A74206[n], return(A74206[n])); A74206[n]=sumdiv(n, i, if(i<4, i<n, i<n, A074206(i)))} \\ Use memoization for computing many values. - _M. F. Hasler_, Oct 12 2018
```
```PARI
first(n) = {my(res = vector(n, i, 1)); for(i = 2, n, for(j = 2, n \ i, res[i*j] += res[i])); concat(0, res)} \\ _David A. Corneth_, Oct 13 2018
```
```PARI
first(n) = {my(res = vector(n, i, 1)); for(i = 2, n, d = divisors(i); res[i] += sum(j = 1, #d-1, res[d[j]])); concat(0, res)} \\ somewhat faster than progs above for finding first terms of n. \\ _David A. Corneth_, Oct 12 2018
```
```PARI
a(n)={if(!n, 0, my(sig=factor(n)[,2], m=vecsum(sig)); sum(k=0, m, prod(i=1, #sig, binomial(sig[i]+k-1, k-1))*sum(r=k, m, binomial(r,k)*(-1)^(r-k))))} \\ _Andrew Howroyd_, Aug 30 2020
```
## Sage
```Sage
@cached_function
def minus_mu(n):
    if n < 2: return n
    return sum(minus_mu(d) for d in divisors(n)[:-1])
# Note that changing the sign of the sum gives the Möbius function A008683.
print([minus_mu(n) for n in (0..96)]) # _Peter Luschny_, Dec 26 2016
```
## Python
```Python
from math import prod
from functools import lru_cache
from sympy import divisors, factorint, prime
@lru_cache(maxsize=None)
def A074206(n): return sum(A074206(d) for d in divisors(prod(prime(i+1)**e for i,e in enumerate(sorted(factorint(n).values(),reverse=True))),generator=True,proper=True)) if n > 1 else n # _Chai Wah Wu_, Sep 16 2022
```
