# a\(n\) is the smallest maximally idempotent integer with n factors, n \>\= 3\.
https://oeis.org/A307537
## JSON
```JSON
[273, 63973, 72719023, 13006678091, 7817013532691]
```
## Mathematica
```Mathematica
(* This program is not suitable to compute large terms. *)
```
```Mathematica
okQ[n_] := Module[{partitions, p, q, lambda}, partitions = {p, q} /. {ToRules[Reduce[1<p<q && n == p q, {p, q}, Integers]]}; lambda = CarmichaelLambda[n]; AllTrue[partitions-1, Divisible[Times @@ #, lambda]&]];
```
```Mathematica
For[Clear[a]; n = 1, n < 70000, n++, If[SquareFreeQ[n], nu = PrimeNu[n]; If[nu >= 3 && !IntegerQ[a[nu]], If[okQ[n], Print["a(", nu, ") = ", n]; a[nu] = n]]]]; (* _Jean-Fran√ßois Alcover_, Jun 20 2019 *)
```
## Python
```Python
# Partial Python code is shown below.  It uses other routines:
# numbthy.factor(n) -- from the Python number theory library, returns a list of
# (p,e) pairs corresponding to the prime factors and their exponents in the factorizations of n
# partitions(n,factor_list) -- takes an integer n and the factor list from above,
# returns a list of all bipartite factorizations of n
# lambda_n -- calculates the carmichael lambda function
# returns True if all partitions of n are idempotent
def isMaximallyIdempotent(n):
    factor_list = numbthy.factor(n)
    partitions_of_n = partitions(n,factor_list)
    lambda_n = carmichael_lambda_with_list(n,factor_list)
    for (p,q) in partitions_of_n:
        pseudo = (p-1)*(q-1)
        if pseudo % lambda_n != 0:
            return False
    return True
```
