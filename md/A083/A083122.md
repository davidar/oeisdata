# a\(1\) \= 1, then the smallest number not included earlier and not a string of 1's such that the concatenation a\(n\), a\(n\+1\) is a palindrome\.
https://oeis.org/A083122
## JSON
```JSON
[1, 21, 2, 12, 121, 1121, 211, 112, 1211, 11121, 2111, 1112, 12111, 111121, 21111, 11112, 121111, 1111121, 211111, 111112, 1211111, 11111121, 2111111, 1111112, 12111111, 111111121, 21111111, 11111112, 121111111, 1111111121, 211111111, 111111112, 1211111111]
```
## Python
```Python
from itertools import count, islice, product
def pals(digs):
    yield from digs
    for d in count(2):
        for p in product(digs, repeat=d//2):
            left = "".join(p)
            for mid in [[""], digs][d%2]:
                yield left + mid + left[::-1]
def folds(s): # generator of suffixes of palindromes starting with s
    for i in range((len(s)+1)//2, len(s)+1):
        for mid in [True, False]:
            t = s[:i] + (s[:i-1][::-1] if mid else s[:i][::-1])
            if t.startswith(s):
                yield t[len(s):]
    yield from ("".join(p)+s[::-1] for p in pals("12"))
def agen():
    s, seen = "1", {"1"}; yield 1
    while True:
        for t in folds(s):
            if len(t) > 0 and set(t) != {"1"} and t not in seen: break
        s = t; seen.add(t); yield int(t)
print(list(islice(agen(), 33))) # _Michael S. Branicky_, Aug 09 2022
```
