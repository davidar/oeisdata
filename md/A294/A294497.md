# Squares k \(not ending in 0\) such that the integer that is built up by concatenating the floors of the square roots of the two\-digit numbers into which the original number is separated \(from right to left\) is the square root of the original number\.
https://oeis.org/A294497
## JSON
```JSON
[1, 4, 9, 16, 25, 36, 49, 64, 81, 225, 625, 1225, 2025, 2601, 2704, 2809, 2916, 3025, 3136, 3249, 3364, 3481, 4225, 5625, 7225, 9025, 22801, 23104, 23409, 50625, 63001, 63504, 75625, 123201, 180625, 203401, 225625, 390625, 432964, 455625, 573049, 680625, 732736, 765625, 2175625, 6260004, 6270016]
```
## Mathematica
```Mathematica
#^2 & /@ Select[Range[10^4], And[Mod[#, 10] != 0, FromDigits@ Map[Floor@ Sqrt@ FromDigits@ # &, Partition[PadLeft[#, 2 Ceiling[Length@ #/2]], 2, 2]] &@ IntegerDigits[#^2] == #] &] (* _Michael De Vlieger_, Nov 23 2017 *)
```
## PARI
```PARI
is(n) = if(issquare(n) == 0||n % 10 == 0, return(0)); my(sq = i = 0, cn = n); while(cn > 0, sq += 10^i * sqrtint(cn % 100); cn \= 100; i++); sq ^ 2 == n \\ _David A. Corneth_, Jan 18 2018
```
## Python
```Python
import math
for k in range(1,1000000000):
   p = 0
   z = 0
   n = k*k
   while n >= 100:
      z = z + int(math.floor(math.sqrt(n % 100)) * math.pow(10, p))
      n = int((n - (n % 100)) / 100)
      p = p + 1
   z = z + int(math.floor(math.sqrt(n)) * math.pow(10, p))
   if z == k and k % 10 > 0:
      print(k * k, k)
```
