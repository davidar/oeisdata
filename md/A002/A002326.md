# Multiplicative order of 2 mod 2n\+1\.
https://oeis.org/A002326
## JSON
```JSON
[1, 2, 4, 3, 6, 10, 12, 4, 8, 18, 6, 11, 20, 18, 28, 5, 10, 12, 36, 12, 20, 14, 12, 23, 21, 8, 52, 20, 18, 58, 60, 6, 12, 66, 22, 35, 9, 20, 30, 39, 54, 82, 8, 28, 11, 12, 10, 36, 48, 30, 100, 51, 12, 106, 36, 36, 28, 44, 12, 24, 110, 20, 100, 7, 14, 130, 18, 36, 68, 138, 46, 60, 28]
```
## Maple
```Maple
a := n -> `if`(n=0, 1, numtheory:-order(2, 2*n+1)):
seq(a(n), n=0..72);
```
## Mathematica
```Mathematica
Table[MultiplicativeOrder[2, 2*n + 1], {n, 0, 100}] (* _Robert G. Wilson v_, Apr 05 2011 *)
```
## PARI
```PARI
a(n)=if(n<0,0,znorder(Mod(2,2*n+1))) /* _Michael Somos_, Mar 31 2005 */
```
## Magma
```Magma
[ 1 ] cat [ Modorder(2, 2*n+1): n in [1..72] ]; // _Klaus Brockhaus_, Dec 03 2008
```
## Haskell
```Haskell
import Data.List (findIndex)
import Data.Maybe (fromJust)
a002326 n = (+ 1) $ fromJust $
            findIndex ((== 0) . (`mod` (2 * n + 1))) $ tail a000225_list
-- _Reinhard Zumkeller_, Apr 22 2013
```
## Sage
```Sage
[Mod(2,n).multiplicative_order() for n in (0..145) if gcd(n,2) == 1]
# Algorithm from _Vladimir Shevelev_ as described in A179680 and presented in Example.
def A002326VS(n):
    s, m, N = 0, 1, 2*n + 1
    while True:
        k = N + m
        v = valuation(k, 2)
        s += v
        m = k >> v
        if m == 1: break
    return s
[A002326VS(n) for n in (0..72)] #
```
## GAP
```GAP
List([0..100],n->OrderMod(2,2*n+1)); # _Muniru A Asiru_, Feb 01 2019
```
## Python
```Python
from sympy import n_order
[n_order(2, 2*n+1) for n in range(73)] # _Hermann Stamm-Wilbrandt_, Jul 27 2021
```
