# Emirps p such that p\+\(sum of digits of p\) and reverse\(p\)\+\(sum of digits of p\) are emirps\.
https://oeis.org/A340843
## JSON
```JSON
[1933, 3391, 32687, 78623, 104087, 109891, 112103, 120283, 123127, 135469, 136217, 161983, 162209, 162391, 163819, 179779, 193261, 198613, 198901, 301211, 316819, 316891, 382021, 389161, 712631, 721321, 726487, 738349, 780401, 784627, 902261, 918361, 918613, 943837, 964531, 977971, 1002247]
```
## Maple
```Maple
revdigs:= proc(n) local L,i;
  L:= convert(n,base,10);
  add(10^(i-1)*L[-i],i=1..nops(L))
end proc:
filter:= proc(n) local r,t,n2,n3;
if not isprime(n) then return false fi;
r:= revdigs(n);
if r = n or not isprime(r) then return false fi;
t:= convert(convert(n,base,10),`+`);
for n2 in [n+t, r+t] do
  if not isprime(n2) then return false fi;
  r:= revdigs(n2);
  if r = n2 or not isprime(r) then return false fi;
od;
true
end proc:
select(filter, [seq(i,i=13..10^6,2)]);
```
## Python
```Python
from sympy import isprime
def sd(n): return sum(map(int, str(n)))
def emirp(n):
  if not isprime(n): return False
  revn = int(str(n)[::-1])
  if n == revn: return False
  return isprime(revn)
def ok(n):
  if not emirp(n): return False
  if not emirp(n + sd(n)): return False
  revn = int(str(n)[::-1])
  return emirp(revn + sd(revn))
def aupto(nn): return [m for m in range(1, nn+1) if ok(m)]
print(aupto(920000)) # _Michael S. Branicky_, Jan 24 2021
```
