# Triangle read by rows, a Narayana related triangle whose rows are refinements of twice the Catalan numbers \(for n \>\= 2\)\.
https://oeis.org/A352687
## JSON
```JSON
[1, 0, 1, 0, 1, 1, 0, 1, 2, 1, 0, 1, 4, 4, 1, 0, 1, 7, 12, 7, 1, 0, 1, 11, 30, 30, 11, 1, 0, 1, 16, 65, 100, 65, 16, 1, 0, 1, 22, 126, 280, 280, 126, 22, 1, 0, 1, 29, 224, 686, 980, 686, 224, 29, 1, 0, 1, 37, 372, 1512, 2940, 2940, 1512, 372, 37, 1]
```
## Maple
```Maple
T := (n, k) -> if n = k then 1 elif k = 0 then 0 else
binomial(n, k)^2*(k*(2*k^2 + (n + 1)*(n - 2*k))) / (n^2*(n - 1)*(n - k + 1)) fi:
seq(seq(T(n, k), k = 0..n), n = 0..10);
# Alternative:
gf := 1 - x + (1 + y)*(1 - x*(y - 1) - sqrt((x*y + x - 1)^2 - 4*x^2*y))/2:
serx := expand(series(gf, x, 16)): coeffy := n -> coeff(serx, x, n):
seq(seq(coeff(coeffy(n), y, k), k = 0..n), n = 0..10);
# Using polynomial recurrence:
P := proc(n, x) option remember; if n < 3 then [1, x, x + x^2] [n + 1] else
((2*n - 3)*(x + 1)*P(n - 1, x) - (n - 3)*(x - 1)^2*P(n - 2, x)) / n fi end:
Trow := n -> seq(coeff(P(n, x), x, k), k = 0..n): seq(Trow(n), n = 0..10);
# Represented by generalized Narayana polynomials:
N := (n, k, x) -> add(((k+1)/(n-k))*binomial(n-k,j-1)*binomial(n-k,j+k)*x^(j+k), j=0..n-2*k): seq(print(ifelse(n=0, 1, expand(N(n,0,x) - N(n,1,x)))), n=0..7);
```
## Mathematica
```Mathematica
H[0, _] := 1; H[1, x_] := x;
```
```Mathematica
H[n_, x_] := x*(x + 1)*Hypergeometric2F1[1 - n, 2 - n, 2, x];
```
```Mathematica
Hrow[n_] := CoefficientList[H[n, x], x]; Table[Hrow[n], {n, 0, 9}] // TableForm
```
## Python
```Python
from math import comb as binomial
def T(n, k):
    if k == n: return 1
    if k == 0: return 0
    return ((binomial(n, k)**2 * (k * (2 * k**2 + (n + 1) * (n - 2 * k))))
           // (n**2 * (n - 1) * (n - k + 1)))
def Trow(n): return [T(n, k) for k in range(n + 1)]
for n in range(10): print(Trow(n))
```
```Python
# The recursion with cache is (much) faster:
from functools import cache
@cache
def T_row(n):
    if n < 3: return ([1], [0, 1], [0, 1, 1])[n]
    A = T_row(n - 2) + [0, 0]
    B = T_row(n - 1) + [1]
    for k in range(n - 1, 1, -1):
        B[k] = (((B[k] + B[k - 1]) * (2 * n - 3)
               - (A[k] - 2 * A[k - 1] + A[k - 2]) * (n - 3)) // n)
    return B
for n in range(10): print(T_row(n))
```
