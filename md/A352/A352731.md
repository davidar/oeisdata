# On a diagonally numbered square grid, with labels starting at 1, this is the number of the last cell that a \(1,n\) leaper reaches before getting trapped when moving to the lowest available unvisited square, or \-1 if it never gets trapped\.
https://oeis.org/A352731
## JSON
```JSON
[-1, 1378, -1, 595, 66, 36, 153, 758, 1185, 78, 1732, 171, 2510, 2094, 1407, 253, 630, 210, 780, 2385, 1326, 300, 1225, 990, 2800, 406, 3267, 4333, 4124, 528, 4309, 741, 5951, 666, 2701, 903, 30418, 820, 3321, 1081, 4186, 990, 8299, 2775, 4560, 1176, 4753, 39951, 5778]
```
## Python
```Python
# reformatted by _R. J. Mathar_, 2023-03-29
class A352731():
    def __init__(self,n) :
        self.n = n
        self.KM=[(n, 1), (1, n), (-1, n), (-n, 1), (-n, -1), (-1, -n), (1, -n), (n, -1)]
    @staticmethod
    def _idx(loc):
        i, j = loc
        return (i+j-1)*(i+j-2)//2 + j
    def _next_move(self,loc, visited):
        i, j = loc
        moves = [(i+io, j+jo) for io, jo in self.KM if i+io>0 and j+jo>0]
        available = [m for m in moves if m not in visited]
        return min(available, default=None, key=lambda x: A352731._idx(x))
    def _aseq(self):
        locs = [[], []]
        loc, s, turn, alst = [(1, 1), (1, 1)], {(1, 1)}, 0, [1]
        m = self._next_move(loc[turn], s)
        while m != None:
            loc[turn], s, turn, alst = m, s|{m}, 0 , alst + [A352731._idx(m)]
            locs[turn] += [loc[turn]]
            m = self._next_move(loc[turn], s)
            if len(s)%100000 == 0:
                print(self.n,'{steps} moves in'.format(steps = len(s)))
        return alst
    def at(self,n) :
        if n == 1 or n == 3:
            return -1
        else:
            return self._aseq()[-1]
for n in range(1,40):
    a352731 = A352731(n)
    print(a352731.at(n))
```
