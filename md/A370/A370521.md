# The smallest number k that can be partitioned in n ways as the sum of two Blum numbers \(A016105\)\.
https://oeis.org/A370521
## JSON
```JSON
[1, 42, 90, 162, 234, 474, 270, 378, 558, 594, 774, 846, 970, 810, 1050, 630, 1370, 1134, 990, 1170, 1470, 1730, 1530, 2054, 1970, 1386, 1638, 1710, 2178, 2070, 2630, 2250, 1890, 2730, 2394, 2310, 3234, 3230, 3530, 2790, 2898, 3650, 3470, 4010, 3570, 3654, 2970, 3150]
```
## Magma
```Magma
pp:=PrimeDivisors; blum:=func<n|#Divisors(n) eq 4 and #pp(n) eq 2 and pp(n)[1] mod 4 eq 3 and pp(n)[2] mod 4 eq 3>;b:=[n: n in [1..5000]|blum(n)]; a:=[]; for n in [0..47] do k:=1; while #RestrictedPartitions(k,2,Set(b)) ne n do k:=k+1; end while; Append(~a,k); end for; a;
```
## Python
```Python
from sympy import factorint
from itertools import takewhile
from collections import Counter
def okA016105(n):
    f = factorint(n)
    return len(f)==2 and sum(f.values())==2 and all(p%4==3 for p in f)
def aupto(N): # N is limit of terms considered; use 2*10**6 for b-file
    s = [k for k in range(1, N+1) if okA016105(k)]
    c = Counter(x+y for i, x in enumerate(s) if 2*i<=N for y in s[i:] if x+y<=N)
    adict = {0: 1}
    for k in sorted(c):
        v = c[k]
        if v not in adict: adict[v] = k
    adict_rev = (adict.get(i) for i in range(max(adict)+1))
    return list(takewhile(lambda v:v!=None, adict_rev))
print(aupto(4010)) # _Michael S. Branicky_, Feb 28 2024
```
