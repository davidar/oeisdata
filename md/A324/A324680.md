# Starting at n, a\(n\) is the largest distance from zero among all positions from which a spot must be revisited on the next move, or zero if no such positions exist, according to the following rules\. On the k\-th step \(k\=1,2,3,\.\.\.\) move a distance of k in the direction of zero\. If the number landed on has been landed on before, move a distance of k away\.
https://oeis.org/A324680
## JSON
```JSON
[0, 0, 0, 0, 0, 0, 0, 3442, 0, 0, 0, 27, 140, 139, 0, 0, 84, 3072845, 0, 0, 638385, 0, 0, 0, 0, 4869724, 0, 0, 0, 464, 43807680, 2117461, 2117462, 2117463, 2117464, 0, 0, 24, 696919, 696918, 179, 1, 0, 1, 1920, 0, 148, 86, 85, 84, 83, 190, 63, 0, 0, 0, 1107]
```
## Python
```Python
#Sequences A324660-A324692 generated by manipulating this trip function
#spots - positions in order with possible repetition
#flee - positions from which we move away from zero with possible repetition
#stuck - positions from which we move to a spot already visited with possible repetition
def trip(n):
    stucklist = list()
    spotsvisited = [n]
    leavingspots = list()
    turn = 0
    forbidden = {n}
    while n != 0:
        turn += 1
        sign = n // abs(n)
        st = sign * turn
        if n - st not in forbidden:
            n = n - st
        else:
            leavingspots.append(n)
            if n + st in forbidden:
                stucklist.append(n)
            n = n + st
        spotsvisited.append(n)
        forbidden.add(n)
    return {'stuck':stucklist, 'spots':spotsvisited,
                'turns':turn, 'flee':leavingspots}
def maxorzero(x):
    if x:
        return max(x)
    return 0
#Actual sequence
def a(n):
    d=trip(n)
    return maxorzero([abs(i) for i in d['stuck']])
```
