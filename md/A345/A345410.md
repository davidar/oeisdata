# a\(n\) is the least number that is the sum of an emirp and its reversal in exactly n ways\.
https://oeis.org/A345410
## JSON
```JSON
[44, 1090, 10450, 5104, 88888, 10780, 289982, 299992, 482174, 478874, 868868, 499994, 1073270, 1087790, 1071070, 1069970, 10904990, 10794980, 1091090, 10892990, 1100000, 29955992, 1101100, 26688662, 31022002, 27599572, 46400354, 44688644, 29821792, 45289244, 30122092, 26988962]
```
## Maple
```Maple
revdigs:= proc(n) local L,i; L:= convert(n,base,10); add(L[-i]*10^(i-1),i=1..nops(L)) end proc:
isemirp1:= proc(n) local r;
if not isprime(n) then return false fi;
r:= revdigs(n);
r > n and isprime(r)
end proc:
E:= select(isemirp1, [seq(seq(seq(i*10^d+j,j=1..10^d-1,2),i=[1,3,7,9]),d=1..5)]):
V:= sort(map(t -> t+revdigs(t),E)):
N:= nops(V):
W:= Vector(16):
i:= 1:
while i < N do
for j from 1 to N-i while V[i+j]=V[i] do od:
if j <= 16 and W[j] = 0 then W[j]:= V[i] fi;
  i:= i+j;
od:
convert(W,list);
```
## Python
```Python
from itertools import product
from collections import Counter
from sympy import isprime, nextprime
def epgen(start=1, end=float('inf')): # generates unique emirp/prime pairs
    digits = 2
    while True:
      for first in "1379":
        for last in "1379":
          if last < first: continue
          for mid in product("0123456789", repeat=digits-2):
            strp = first + "".join(mid) + last
            revstrp = strp[::-1]
            if strp >= revstrp: continue
            p = int(strp)
            if p > end: return
            revp = int(strp[::-1])
            if isprime(p) and isprime(revp): yield (p, revp)
      digits += 1
def aupto(lim):
    alst = []
    c = Counter(sum(ep) for ep in epgen(1, lim) if sum(ep) <= lim)
    r = set(c.values())
    for i in range(1, max(r)+1):
        if i in r: alst.append(min(s for s in c if c[s] == i))
        else: break
    return alst
print(aupto(11*10**5)) # _Michael S. Branicky_, Jun 19 2021
```
