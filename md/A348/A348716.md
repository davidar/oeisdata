# Numbers whose divisors can be partitioned into two disjoint sets without singletons whose harmonic means are both integers in a record number of ways\.
https://oeis.org/A348716
## JSON
```JSON
[1, 12, 24, 60, 84, 120, 240, 360, 420, 672, 840, 1260, 1680, 2160, 2520, 3360, 6720, 7560, 10080, 15120, 21840, 27720, 30240, 50400, 60480, 65520, 83160, 98280, 110880, 131040]
```
## Mathematica
```Mathematica
q[d_] := Length[d] > 1 && IntegerQ@HarmonicMean[d]; c[n_] := Count[Subsets[(d = Divisors[n])], _?(q[#] && q[Complement[d, #]] &)]/2; cm = -1; s = {}; Do[If[(c1 = c[n]) > cm, cm = c1; AppendTo[s, n]], {n, 1, 240}]; s
```
## Python
```Python
from fractions import Fraction
from itertools import count, islice, combinations
from sympy import divisors
def A348716_gen(): # generator of terms
    c = 0
    yield 1
    for n in count(2):
        divs = tuple(divisors(n, generator=True))
        l, b = len(divs), sum(Fraction(1,d) for d in divs)
        if l>=4 and 2**(l-1)-l>c:
            m = sum(1 for k in range(2,(l-1>>1)+1) for p in combinations(divs,k) if not ((s:=sum(Fraction(1,d) for d in p)).denominator*k%(s.numerator) or (r:=b-s).denominator*(l-k)%(r.numerator)))
            if l&1 == 0:
                k = l>>1
                m += sum(1 for p in combinations(divs,k) if 1 in p and not ((s:=sum(Fraction(1,d) for d in p)).denominator*k%(s.numerator) or (r:=b-s).denominator*k%(r.numerator)))
            if m > c:
                yield n
                c = m
A348716_list = list(islice(A348716_gen(),5)) # _Chai Wah Wu_, Sep 24 2023
```
