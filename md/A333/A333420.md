# Table T\(n,k\) read by upward antidiagonals\. T\(n,k\) is the maximum value of Product\_\{i\=1\.\.n\} Sum\_\{j\=1\.\.k\} r\[\(i\-1\)\*k\+j\] among all permutations r of \{1\.\.kn\}\.
https://oeis.org/A333420
## JSON
```JSON
[1, 2, 3, 6, 25, 6, 24, 343, 110, 10, 120, 6561, 3375, 324, 15, 720, 161051, 144400, 17576, 756, 21, 5040, 4826809, 7962624, 1336336, 64000, 1521, 28, 40320, 170859375, 535387328, 130691232, 7595536, 185193, 2756, 36, 3628800, 6975757441]
```
## Python
```Python
from itertools import combinations, permutations
from sympy import factorial
def T(n,k): # T(n,k) for A333420
    if k == 1:
        return int(factorial(n))
    if n == 1:
        return k*(k+1)//2
    if k % 2 == 0 or (k >= n-1 and n % 2 == 1):
        return (k*(k*n+1)//2)**n
    if k >= n-1 and n % 2 == 0 and k % 2 == 1:
        return ((k**2*(k*n+1)**2-1)//4)**(n//2)
    nk = n*k
    nktuple = tuple(range(1,nk+1))
    nkset = set(nktuple)
    count = 0
    for firsttuple in combinations(nktuple,n):
        nexttupleset = nkset-set(firsttuple)
        for s in permutations(sorted(nexttupleset),nk-2*n):
            llist = sorted(nexttupleset-set(s),reverse=True)
            t = list(firsttuple)
            for i in range(0,k-2):
                itn = i*n
                for j in range(n):
                        t[j] += s[itn+j]
            t.sort()
            w = 1
            for i in range(n):
                w *= llist[i]+t[i]
            if w > count:
                count = w
    return count
```
