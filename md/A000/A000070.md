# a\(n\) \= Sum\_\{k\=0\.\.n\} p\(k\) where p\(k\) \= number of partitions of k \(A000041\)\.
https://oeis.org/A000070
## JSON
```JSON
[1, 2, 4, 7, 12, 19, 30, 45, 67, 97, 139, 195, 272, 373, 508, 684, 915, 1212, 1597, 2087, 2714, 3506, 4508, 5763, 7338, 9296, 11732, 14742, 18460, 23025, 28629, 35471, 43820, 53963, 66273, 81156, 99133, 120770, 146785, 177970, 215308, 259891, 313065, 376326, 451501]
```
## Maple
```Maple
with(combinat): a:=n->add(numbpart(j),j=0..n): seq(a(n), n=0..44); # _Zerinvary Lajos_, Aug 26 2008
```
## Mathematica
```Mathematica
CoefficientList[ Series[1/(1 - x)*Product[1/(1 - x^k), {k, 75}], {x, 0, 45}], x] (* _Robert G. Wilson v_, Jul 13 2004 *)
```
```Mathematica
Table[ Count[ Flatten@ IntegerPartitions@ n, 1], {n, 45}] (* _Robert G. Wilson v_, Aug 06 2008 *)
```
```Mathematica
Join[{1}, Accumulate[PartitionsP[Range[50]]]+1] (* _Harvey P. Dale, Mar 12 2013 *)
```
```Mathematica
a[ n_] := SeriesCoefficient[ 1 / (1 - x) / QPochhammer[ x], {x, 0, n}]; (* _Michael Somos_, Nov 09 2013 *)
```
```Mathematica
Accumulate[PartitionsP[Range[0,49]]] (* _George Beck_, Oct 23 2014; typo fixed by _Virgile Andreani_, Jul 10 2016 *)
```
## PARI
```PARI
{a(n) = if( n<0, 0, polcoeff( 1 / prod(m=1, n, 1 - x^m, 1 + x * O(x^n)) / (1 - x), n))}; /* _Michael Somos_, Nov 08 2002 */
```
```PARI
x='x+O('x^66); Vec(1/((1-x)*eta(x))) /* _Joerg Arndt_, May 15 2011 */
```
```PARI
a(n) = sum(k=0, n, numbpart(k)); \\ _Michel Marcus_, Sep 16 2016
```
## Haskell
```Haskell
a000070 = p a028310_list where
   p _          0 = 1
   p ks'@(k:ks) m = if m < k then 0 else p ks' (m - k) + p ks m
-- _Reinhard Zumkeller_, Nov 06 2012
```
## Sage
```Sage
def A000070_list(leng):
    p = [number_of_partitions(n) for n in range(leng)]
    return [add(p[:k+1]) for k in range(leng)]
A000070_list(45) # _Peter Luschny_, Sep 15 2014
```
## GAP
```GAP
List([0..45],n->Sum([0..n],k->NrPartitions(k))); # _Muniru A Asiru_, Jul 25 2018
```
## Python
```Python
from itertools import accumulate
def A000070iter(n):
    L = [0]*n; L[0] = 1
    def numpart(n):
        S = 0; J = n-1; k = 2
        while 0 <= J:
            T = L[J]
            S = S+T if (k//2)%2 else S-T
            J -= k  if (k)%2 else k//2
            k += 1
        return S
    for j in range(1, n): L[j] = numpart(j)
    return accumulate(L)
print(list(A000070iter(100))) # _Peter Luschny_, Aug 30 2019
```
```Python
# Using function A365676Row. Compare also A365675.
from itertools import accumulate
def A000070List(size: int) -> list[int]:
    return [sum(accumulate(reversed(A365676Row(n)))) for n in range(size)]
print(A000070List(45))  # _Peter Luschny_, Sep 16 2023
```
