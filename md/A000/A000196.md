# Integer part of square root of n\. Or, number of positive squares <\= n\. Or, n appears 2n\+1 times\.
https://oeis.org/A000196
## JSON
```JSON
[0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10]
```
## Maple
```Maple
Digits := 100; A000196 := n->floor(evalf(sqrt(n)));
```
## Mathematica
```Mathematica
Table[n, {n, 0, 20}, {2n + 1}] //Flatten (* _Zak Seidov_ Mar 19 2011 *)
```
```Mathematica
IntegerPart[Sqrt[Range[0, 110]]] (* _Harvey P. Dale_, May 23 2012 *)
```
```Mathematica
Floor[Sqrt[Range[0, 99]]] (* _Alonso del Arte_, Dec 31 2013 *)
```
```Mathematica
a[ n_] := SeriesCoefficient[ (EllipticTheta[ 3, 0, x]  - 1) / (2 (1 - x)), {x, 0, n}]; (* _Michael Somos_, May 28 2014 *)
```
## Magma
```Magma
[Isqrt(n) : n in [0..100]];
```
## PARI
```PARI
{a(n) = if( n<0, 0, floor(sqrt(n)))};
```
```PARI
{a(n) = if( n<0, 0, sqrtint(n))};
```
## Haskell
```Haskell
import Data.Bits (shiftL, shiftR)
a000196 :: Integer -> Integer
a000196 0 = 0
a000196 n = newton n (findx0 n 1) where
   -- find x0 == 2^(a+1), such that 4^a <= n < 4^(a+1).
   findx0 0 b = b
   findx0 a b = findx0 (a `shiftR` 2) (b `shiftL` 1)
   newton n x = if x' < x then newton n x' else x
                where x' = (x + n `div` x) `div` 2
a000196_list = concat $ zipWith replicate [1,3..] [0..]
-- _Reinhard Zumkeller_, Apr 12 2012, Oct 23 2010
```
## Python
```Python
# from http://code.activestate.com/recipes/577821-integer-square-root-function/
def A000196(n):
  if n < 0:
    raise ValueError('only defined for nonnegative n')
  if n == 0:
    return 0
  a, b = divmod(n.bit_length(), 2)
  j = 2**(a+b)
  while True:
    k = (j + n//j)//2
    if k >= j:
      return j
    j = k
print([A000196(n)for n in range(102)])
# _Jason Kimberley_, Nov 09 2016
```
```Python
from math import isqrt
def a(n): return isqrt(n)
print([a(n) for n in range(102)]) # _Michael S. Branicky_, Feb 15 2023
```
## Scheme
```Scheme
;; The following implementation uses higher order function LEFTINV-LEASTMONO-NC2NC from my IntSeq-library. It returns the least monotonic left inverse of any strictly growing function (see the comment-section for the definition) and although it does not converge as fast to the result as many specialized integer square root algorithms, at least it does not involve any floating point arithmetic. Thus with correctly implemented bignums it will produce correct results even with very large arguments, in contrast to just taking the floor of (sqrt n).
;; Source of LEFTINV-LEASTMONO-NC2NC can be found under https://github.com/karttu/IntSeq/blob/master/src/Transforms/transforms-core.ss and the definition of A000290 is given under that entry.
(define A000196 (LEFTINV-LEASTMONO-NC2NC 0 0 A000290)) ;; _Antti Karttunen_, Oct 06 2017
```
## Julia
```Julia
a(n) = isqrt(n) # _Paul Muljadi_, Jun 03 2024
```
