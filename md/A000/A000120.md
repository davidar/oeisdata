# 1's\-counting sequence: number of 1's in binary expansion of n \(or the binary weight of n\)\.
https://oeis.org/A000120
## JSON
```JSON
[0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3]
```
## Maple
```Maple
A000120 := proc(n) local w,m,i; w := 0; m := n; while m > 0 do i := m mod 2; w := w+i; m := (m-i)/2; od; w; end: wt := A000120;
A000120 := n -> add(i, i=convert(n,base,2)): # _Peter Luschny_, Feb 03 2011
with(Bits): p:=n->ilog2(n-And(n,n-1)): seq(p(binomial(2*n,n)),n=0..200) # _Gary Detlefs_, Jan 27 2019
```
## Mathematica
```Mathematica
Table[DigitCount[n, 2, 1], {n, 0, 105}]
```
```Mathematica
Nest[Flatten[# /. # -> {#, # + 1}] &, {0}, 7] (* _Robert G. Wilson v_, Sep 27 2011 *)
```
```Mathematica
Table[Plus @@ IntegerDigits[n, 2], {n, 0, 104}]
```
```Mathematica
Nest[Join[#, # + 1] &, {0}, 7] (* _IWABUCHI Yu(u)ki_, Jul 19 2012 *)
```
```Mathematica
Log[2, Nest[Join[#, 2#] &, {1}, 14]] (* gives 2^14 term, _Carlos Alves_, Mar 30 2014 *)
```
## PARI
```PARI
{a(n) = if( n<0, 0, 2*n - valuation((2*n)!, 2))};
```
```PARI
{a(n) = if( n<0, 0, subst(Pol(binary(n)), x ,1))};
```
```PARI
{a(n) = if( n<1, 0, a(n\2) + n%2)}; /* _Michael Somos_, Mar 06 2004 */
```
```PARI
a(n)=my(v=binary(n));sum(i=1,#v,v[i]) \\ _Charles R Greathouse IV_, Jun 24 2011
```
```PARI
a(n)=norml2(binary(n)) \\ better use {A000120=hammingweight}. - _M. F. Hasler_, Oct 09 2012, edited Feb 27 2020
```
```PARI
a(n)=hammingweight(n) \\ _Michel Marcus_, Oct 19 2013
```
## Lisp
```Lisp
(defun floor-to-power (n pow) (declare (fixnum pow)) (expt pow (floor (log n pow)))) (defun enabled-bits (n) (if (< n 4) (n-th n (list 0 1 1 2)) (+ (enabled-bits (floor (/ n (floor-to-power n 4)))) (enabled-bits (mod n (floor-to-power n 4)))))) ; Stephen K. Touset (stephen(AT)touset.org), Apr 04 2007
```
## Haskell
```Haskell
import Data.Bits (Bits, popCount)
a000120 :: (Integral t, Bits t) => t -> Int
a000120 = popCount
a000120_list = 0 : c [1] where c (x:xs) = x : c (xs ++ [x,x+1])
-- _Reinhard Zumkeller_, Aug 26 2013, Feb 19 2012, Jun 16 2011, Mar 07 2011
```
```Haskell
a000120 = concat r
    where r = [0] : (map.map) (+1) (scanl1 (++) r)
-- _Luke Palmer_, Feb 16 2014
```
## Sage
```Sage
def A000120(n):
    if n <= 1: return Integer(n)
    return A000120(n//2) + n%2
[A000120(n) for n in range(105)]  # _Peter Luschny_, Nov 19 2012
```
```Sage
def A000120(n) : return sum(n.digits(2)) # _Eric M. Schmidt_, Apr 26 2013
```
## Python
```Python
def A000120(n): return bin(n).count('1') # _Chai Wah Wu_, Sep 03 2014
```
```Python
import numpy as np
A000120 = np.array([0], dtype="uint8")
for bitrange in range(25): A000120 = np.append(A000120, np.add(A000120, 1))
print([A000120[n] for n in range(0, 105)]) # _Karl-Heinz Hofmann_, Nov 07 2022
```
```Python
def A000120(n): return n.bit_count() # Requires Python 3.10 or higher. - _Pontus von BrÃ¶mssen_, Nov 08 2022
```
```Python
# Also see links.
```
## Scala
```Scala
(0 to 127).map(Integer.bitCount(_)) // _Alonso del Arte_, Mar 05 2019
```
## Magma
```Magma
[Multiplicity(Intseq(n, 2), 1): n in [0..104]]; // _Marius A. Burtea_, Jan 22 2020
```
```Magma
[&+Intseq(n, 2):n in [0..104]]; // _Marius A. Burtea_, Jan 22 2020
```
