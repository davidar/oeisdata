# Fibonacci numbers: F\(n\) \= F\(n\-1\) \+ F\(n\-2\) with F\(0\) \= 0 and F\(1\) \= 1\.
https://oeis.org/A000045
## JSON
```JSON
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155]
```
## Maple
```Maple
A000045 := proc(n) combinat[fibonacci](n); end;
ZL:=[S, {a = Atom, b = Atom, S = Prod(X,Sequence(Prod(X,b))), X = Sequence(b,card >= 1)}, unlabelled]: seq(combstruct[count](ZL, size=n), n=0..38); # _Zerinvary Lajos_, Apr 04 2008
spec := [B, {B=Sequence(Set(Z, card>1))}, unlabeled ]: seq(combstruct[count](spec, size=n), n=1..39); # _Zerinvary Lajos_, Apr 04 2008
# The following Maple command isFib(n) yields true or false depending on whether n is a Fibonacci number or not.
with(combinat): isFib := proc(n) local a: a := proc(n) local j: for j while fibonacci(j) <= n do fibonacci(j) end do: fibonacci(j-1) end proc: evalb(a(n) = n) end proc: # _Emeric Deutsch_, Nov 11 2014
```
## Mathematica
```Mathematica
Table[Fibonacci[k], {k, 0, 50}] (* _Mohammad K. Azarian_, Jul 11 2015 *)
```
```Mathematica
Table[2^n Sqrt @ Product[(Cos[Pi k/(n + 1)]^2 + 1/4), {k, n}] // FullSimplify, {n, 15}]; (* Kasteleyn's formula specialized, _Sarah-Marie Belcastro_, Jul 04 2009 *)
```
```Mathematica
LinearRecurrence[{1, 1}, {0, 1}, 40] (* _Harvey P. Dale_, Aug 03 2014 *)
```
```Mathematica
Fibonacci[Range[0, 20]] (* _Eric W. Weisstein_, Sep 22 2017 *)
```
```Mathematica
CoefficientList[Series[-(x/(-1 + x + x^2)), {x, 0, 20}], x] (* _Eric W. Weisstein_, Sep 22 2017 *)
```
## Axiom
```Axiom
[fibonacci(n) for n in 0..50]
```
## Magma
```Magma
[Fibonacci(n): n in [0..38]];
```
## Maxima
```Maxima
makelist(fib(n),n,0,100); /* _Martin Ettl_, Oct 21 2012 */
```
## PARI
```PARI
a(n) = fibonacci(n)
```
```PARI
a(n) = imag(quadgen(5)^n)
```
```PARI
a(n)=my(phi=quadgen(5));(phi^n-(-1/phi)^n)/(2*phi-1) \\ _Charles R Greathouse IV_, Jun 17 2012
```
## Python
```Python
# From _Jaap Spies_, Jan 05 2007, updated by _Peter Luschny_, Feb 21 2023:
from itertools import islice
def fib_gen():
    x, y = 0, 1
    while True:
        yield x
        x, y = y, x + y
fib_list = lambda n: list(islice(fib_gen(), n))
```
```Python
def A000045(n, F=[0,1]):
    F.extend(sum(F[-2:])for _ in range(n-len(F)+1)); return F[n] # _M. F. Hasler_, Feb 17 2023
```
## Sage
```Sage
# Demonstration program from _Jaap Spies_:
a = sloane.A000045; # choose sequence
print(a)            # This returns the name of the sequence.
print(a(38))        # This returns the 38th term of the sequence.
print(a.list(39))   # This returns a list of the first 39 terms.
```
```Sage
a = BinaryRecurrenceSequence(1,1); print([a(n) for n in range(20)])
# Closed form integer formula with F(1) = 0 from Paul Hankin (see link).
F = lambda n: (4<<(n-1)*(n+2))//((4<<2*(n-1))-(2<<(n-1))-1)&((2<<(n-1))-1)
print([F(n) for n in range(20)]) # _Peter Luschny_, Aug 28 2016
```
```Sage
print(list(fibonacci_sequence(0, 40))) # _Bruno Berselli_, Jun 26 2014
```
## Haskell
```Haskell
-- Based on code from http://www.haskell.org/haskellwiki/The_Fibonacci_sequence
-- which also has other versions.
fib :: Int -> Integer
fib n = fibs !! n
    where
        fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
{- Example of use: map fib [0..38] _Gerald McGarvey_, Sep 29 2009 -}
```
## Julia
```Julia
function fib(n)
   F = BigInt[1 1; 1 0]
   Fn = F^n
   Fn[2, 1]
end
println([fib(n) for n in 0:38]) # _Peter Luschny_, Feb 23 2017
```
```Julia
# faster
function fibrec(n::Int)
    n == 0 && return (BigInt(0), BigInt(1))
    a, b = fibrec(div(n, 2))
    c = a * (b * 2 - a)
    d = a * a + b * b
    iseven(n) ? (c, d) : (d, c + d)
end
fibonacci(n::Int) = fibrec(n)[1]
println([fibonacci(n) for n in 0:40]) # _Peter Luschny_, Apr 03 2022
```
## GAP
```GAP
Fib:=[0,1];; for n in [3..10^3] do Fib[n]:=Fib[n-1]+Fib[n-2]; od; Fib; # _Muniru A Asiru_, Sep 03 2017
```
## Scala
```Scala
def fibonacci(n: BigInt): BigInt = {
  val zero = BigInt(0)
  def fibTail(n: BigInt, a: BigInt, b: BigInt): BigInt = n match {
    case `zero` => a
    case _ => fibTail(n - 1, b, a + b)
  }
  fibTail(n, 0, 1)
} // Based on "Case 3: Tail Recursion" from Carrasquel (2016) link
(0 to 49).map(fibonacci(_)) // _Alonso del Arte_, Apr 13 2019
```
