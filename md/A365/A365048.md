# a\(n\) is the number of steps required for the n\-th odd prime number to reach 3 when iterating the following hailstone map: If P\+1 \=\= 0 \(mod 6\), then the next number \= smallest prime \>\= P \+ \(P\-1\)/2; otherwise the next number \= largest prime <\= \(P\+1\)/2\.
https://oeis.org/A365048
## JSON
```JSON
[0, 2, 1, 6, 2, 5, 2, 4, 4, 3, 3, 5, 3, 8, 5, 13, 4, 4, 7, 4, 4, 6, 12, 9, 6, 9, 6, 6, 14, 5, 8, 11, 5, 8, 5, 5, 5, 16, 13, 13, 13, 13, 10, 7, 10, 10, 7, 15, 15, 15, 12, 15, 15, 12, 12, 12, 9, 6, 12, 6, 12, 6, 17, 6, 14, 6, 17, 14, 14, 11, 11, 14, 14, 14, 8, 11, 11, 14, 11, 8, 11, 16]
```
## Mathematica
```Mathematica
A365048[n_]:=Length[NestWhileList[If[Divisible[#+1,6],NextPrime[#+(#-1)/2-1],NextPrime[(#+1)/2+1,-1]]&,Prime[n+1],#>3&]]-1;Array[A365048,100] (* _Paolo Xausa_, Nov 13 2023 *)
```
## Python
```Python
from sympy import nextprime, prevprime
def hailstone(prime):
  if (prime + 1) % 6 == 0:
     jump = prime + ((prime - 1) / 2)
     jump = nextprime(jump - 1)
  else:
     jump = ((prime + 1) / 2)
     jump = prevprime(jump + 1)
  return jump
q = 2
lst = []
while q < 3000:
   count = 0
   p = nextprime(q)
   q = p
   while p != 3:
      p = hailstone(p)
      count = count + 1
   lst.append(count)
```
