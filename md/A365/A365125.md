# Put a positive charge at 0 and a negative charge at 1, then keep adding alternating charges at points of zero potential; this is the decimal expansion of the limit\.
https://oeis.org/A365125
## JSON
```JSON
[6, 8, 7, 8, 4, 1, 8, 1, 0, 3, 2, 8, 3, 8, 9, 2, 6, 3, 2, 7, 1, 3, 4, 4, 0, 4, 4, 0, 9, 8, 8, 3, 3, 4, 8, 6, 1, 1, 5, 8, 3, 9, 7, 9, 4, 8, 7, 6, 6, 8, 9, 5, 4, 1, 1, 7, 4, 7, 5, 8, 6, 6, 9, 4, 4, 1, 0, 7, 8, 5, 2, 8, 1, 7, 2, 1, 2, 4, 7, 5, 3, 8, 9, 1, 0, 8, 7, 9, 1, 2, 6, 5, 7, 8, 9, 7, 8, 5, 3, 6]
```
## Mathematica
```Mathematica
p={0,1};
```
```Mathematica
For[r=1,r<39,++r,p=Append[p,x/.NSolve[{Sum[1/(x-p[[k]]),{k,1,Length[p]}]==0,(x-p[[-1]])*(x-p[[-2]])<0},x,WorkingPrecision -> 30][[1,1]]];];
```
```Mathematica
A365125 = RealDigits[Floor[10^10*p[[-1]]]][[1]]
```
## Python
```Python
from decimal import Decimal, getcontext, ROUND_UP, ROUND_DOWN
getcontext().prec = 100
def nm(f, df, x):
    for i in range(10):
        x -= f(x)/df(x)
    return x
def flip_rounding():
    if getcontext().rounding == ROUND_UP: getcontext().rounding = ROUND_DOWN
    else: getcontext().rounding = ROUND_UP
def get_zero(vs, rounding):
    getcontext().rounding = rounding
    def p(x,v):
        flip_rounding(); t = x-v
        flip_rounding(); return 1/t
    def dp(x,v):
        flip_rounding(); t = x-v; t = t**2
        flip_rounding(); return -1/t
    def f(x): return sum(p(x,vs[n]) for n in range(len(vs)))
    def df(x): return sum(dp(x,vs[n]) for n in range(len(vs)))
    sign = -1 if rounding == ROUND_DOWN else 1
    return nm(f, df, (vs[-1]+vs[-2])/2+sign*abs(vs[-1]-vs[-2])/3)
v_lo = [Decimal(0), Decimal(1)]
v_up = [Decimal(0), Decimal(1)]
for r in range(150):
    v_lo.append(get_zero(v_lo, ROUND_DOWN))
    v_up.append(get_zero(v_up, ROUND_UP))
lower_bounds = [v_lo[i] for i in range(0, len(v_lo), 2)]
upper_bounds = [v_up[i] for i in range(1, len(v_up), 2)]
right = True
A365125 = [int(l) for l, u in zip(str(lower_bounds[-1])[2:], str(upper_bounds[-1])[2:]) if right and (right := (l == u))]
```
