# Positive integers that contain only odd\-length runs of 0's and 1's in their binary expansion\.
https://oeis.org/A160530
## JSON
```JSON
[1, 2, 5, 7, 8, 10, 14, 17, 21, 23, 29, 31, 32, 34, 40, 42, 46, 56, 58, 62, 65, 69, 71, 81, 85, 87, 93, 95, 113, 117, 119, 125, 127, 128, 130, 136, 138, 142, 160, 162, 168, 170, 174, 184, 186, 190, 224, 226, 232, 234, 238, 248, 250, 254, 257, 261, 263, 273, 277, 279]
```
## Maple
```Maple
Runs := proc (L) local j, r, i, k: j := 1; r[j] := L[1]: for i from 2 to nops(L) do if L[i] = L[i-1] then r[j] := r[j], L[i] else j := j+1: r[j] := L[i] end if end do: [seq([r[k]], k = 1 .. j)] end proc: RunLengths := proc (L) map(nops, Runs(L)) end proc: c := proc (n) ListTools:-Reverse(convert(n, base, 2)): RunLengths(%) end proc: A := {}: for n to 280 do if type(product(c(n)[j], j = 1 .. nops(c(n))), odd) = true then A := `union`(A, {n}) else  end if end do: A; # most of the Maple program is due to _W. Edwin Clark._ - _Emeric Deutsch_, Jan 26 2018
# Alternative:
filter:= proc(n) option remember; local t;
if n::even then
  t:= padic:-ordp(n,2);
  if t::even then return false fi;
  procname(n/2^t)
else
  t:= padic:-ordp(n+1,2);
  if t::even then return false fi;
  procname((n+1)/2^t-1)
  fi
end proc:
filter(0):= true:
select(filter, [$1..1000]); # _Robert Israel_, Jan 26 2018
```
## Mathematica
```Mathematica
Select[Range[300],And@@OddQ/@Length/@Split[IntegerDigits[ #,2]]&] (* _Ray Chandler_, May 19 2009 *)
```
## Python
```Python
from itertools import groupby
def ok(n): return all(len(list(g))%2 == 1 for k, g in groupby(bin(n)[2:]))
print([i for i in range(1, 280) if ok(i)]) # _Michael S. Branicky_, Jan 04 2021
```
