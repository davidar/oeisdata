# The number of odd partitions of consecutive odd integers\.
https://oeis.org/A160786
## JSON
```JSON
[1, 2, 4, 8, 16, 29, 52, 90, 151, 248, 400, 632, 985, 1512, 2291, 3431, 5084, 7456, 10836, 15613, 22316, 31659, 44601, 62416, 86809, 120025, 165028, 225710, 307161, 416006, 560864, 752877, 1006426, 1340012, 1777365, 2348821, 3093095, 4059416, 5310255, 6924691]
```
## Maple
```Maple
b:= proc(n, i) option remember; `if`(n=0, [1, 0$3],
      `if`(i<1, [0$4], b(n, i-1)+`if`(i>n, [0$4], (p->
      `if`(irem(i, 2)=0, [p[3], p[4], p[1], p[2]],
          [p[2], p[1], p[4], p[3]]))(b(n-i, i)))))
    end:
a:= n-> b(2*n+1$2)[2]:
seq(a(n), n=0..40);  # _Alois P. Heinz_, Feb 16 2014
```
## Mathematica
```Mathematica
b[n_, i_] := b[n, i] = If[n==0, {1, 0, 0, 0}, If[i<1, {0, 0, 0, 0}, b[n, i-1] + If[i>n, {0, 0, 0, 0}, Function[{p}, If[Mod[i, 2]==0, p[[{3, 4, 1, 2}]], p[[{2, 1, 4, 3}]]]][b[n-i, i]]]]]; a[n_] := b[2*n+1, 2*n+1][[2]]; Table[a[n], {n, 0, 40}] (* _Jean-Fran√ßois Alcover_, Jul 01 2015, after _Alois P. Heinz_ *)
(* Slow but easy to read *)
a[n_] := Length@IntegerPartitions[2 n + 1, {1, 2 n + 1, 2}]
a /@ Range[0, 25]
(* _Leo C. Stein_, Nov 11 2020 *)
(* Faster, don't build the partitions themselves *)
(* Number of partitions of n into exactly k parts *)
P[0, 0] = 1;
P[n_, k_] := 0 /; ((k <= 0) || (n <= 0))
P[n_, k_] := P[n, k] = P[n - k, k] + P[n - 1, k - 1]
a[n_] := Sum[P[2 n + 1, k], {k, 1, 2 n + 1, 2}]
a /@ Range[0, 40]
(* _Leo C. Stein_, Nov 11 2020 *)
```
## Python
```Python
# Could be memoized for speedup
def numoddpart(n, m=1):
    """The number of partitions of n into an odd number of parts of size at least m"""
    if n < m:
        return 0
    elif n == m:
        return 1
    else:
        # 1 (namely n = n) and all partitions of the form
        # k + even partitions that start with >= k
        return 1 + sum([numevenpart(n - k,  k) for k in range(m, n//3 + 1)])
def numevenpart(n, m=1):
    """The number of partitions of n into an even number of parts of size at least m"""
    if n < 2*m:
        return 0
    elif n == 2*m:
        return 1
    else:
        return sum([numoddpart(n - k,  k) for k in range(m,  n//2 + 1)])
[numoddpart(n) for n in range(1, 70, 2)]
```
```Python
# dict to memoize
ps = {(0,0): 1}
def p(n, k):
    """Number of partitions of n into exactly k parts"""
    if (n,k) in ps: return ps[(n,k)]
    if (n<=0) or (k<=0): return 0
    ps[(n,k)] = p(n-k,k) + p(n-1,k-1)
    return ps[(n,k)]
def a(n): return sum([p(2*n+1, k) for k in range(1,2*n+3,2)])
[a(n) for n in range(0,41)]
# _Leo C. Stein_, Nov 11 2020
```
