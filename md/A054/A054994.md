# Numbers of the form q1^b1 \* q2^b2 \* q3^b3 \* q4^b4 \* q5^b5 \* \.\.\. where q1\=5, q2\=13, q3\=17, q4\=29, q5\=37, \.\.\. \(A002144\) and b1 \>\= b2 \>\= b3 \>\= b4 \>\= b5 \>\= \.\.\.\.
https://oeis.org/A054994
## JSON
```JSON
[1, 5, 25, 65, 125, 325, 625, 1105, 1625, 3125, 4225, 5525, 8125, 15625, 21125, 27625, 32045, 40625, 71825, 78125, 105625, 138125, 160225, 203125, 274625, 359125, 390625, 528125, 690625, 801125, 1015625, 1185665, 1221025, 1373125, 1795625]
```
## Mathematica
```Mathematica
maxTerm = 10^15;(* this limit gives ~ 500 terms *) maxNumberOfExponents = 9;(* this limit has to be increased until the number of reaped terms no longer changes *) bmax = Ceiling[ Log[ maxTerm]/Log[q]]; q = Reap[For[k = 0 ; cnt = 0, cnt <= maxNumberOfExponents, k++, If[PrimeQ[4*k + 1], Sow[4*k + 1]; cnt++]]][[2, 1]]; Clear[b]; b[maxNumberOfExponents + 1] = 0; iter = Sequence @@ Table[{b[k], b[k + 1], bmax[[k]]}, {k, maxNumberOfExponents, 1, -1}]; Reap[ Do[an = Product[q[[k]]^b[k], {k, 1, maxNumberOfExponents}]; If[an <= maxTerm, Print[an]; Sow[an]], Evaluate[iter]]][[2, 1]] // Flatten // Union (* _Jean-François Alcover_, Jan 18 2013 *)
```
## PARI
```PARI
list(lim)=
{
  my(u=[1], v=List(), w=v, pr, t=1);
  forprime(p=5,,
    if(p%4>1, next);
    t*=p;
    if(t>lim, break);
    listput(w,t)
  );
  for(i=1,#w,
    pr=1;
    for(e=1,logint(lim\=1,w[i]),
      pr*=w[i];
      for(j=1,#u,
        t=pr*u[j];
        if(t>lim, break);
        listput(v,t)
      )
    );
    if(w[i]^2<lim, u=Set(concat(Vec(v),u)); v=List());
  );
  Set(concat(Vec(v),u));
} \\ _Charles R Greathouse IV_, Dec 11 2016
```
## Python
```Python
def generate_A054994():
    """generate arbitrarily many elements of the sequence.
    TO_DO is a list of pairs (radius, exponents) where
    "exponents" is a weakly decreasing sequence, and
    radius == prod(prime_4k_plus_1(i)**j for i,j in enumerate(exponents))
    An example entry is (5525, (2, 1, 1)) because 5525 = 5**2 * 13 * 17.
    """
    TO_DO = {(1,())}
    while True:
        radius, exponents = min(TO_DO)
        yield radius #, exponents
        TO_DO.remove((radius, exponents))
        TO_DO.update(successors(radius,exponents))
def successors(radius,exponents):
    # try to increase each exponent by 1 if possible
    for i,e in enumerate(exponents):
        if i==0 or exponents[i-1]>e:
            # can add 1 in position i without violating monotonicity
            yield (radius*prime_4k_plus_1(i), exponents[:i]+(e+1,)+exponents[i+1:])
    if exponents==() or exponents[-1]>0: # add new exponent 1 at the end:
        yield (radius*prime_4k_plus_1(len(exponents)), exponents+(1,))
from sympy import isprime
primes_congruent_1_mod_4 = [5] # will be filled with 5,13,17,29,37,...
def prime_4k_plus_1(i): # the i-th prime that is congruent to 1 mod 4
    while i>=len(primes_congruent_1_mod_4): # generate primes on demand
        n = primes_congruent_1_mod_4[-1]+4
        while not isprime(n): n += 4
        primes_congruent_1_mod_4.append(n)
    return primes_congruent_1_mod_4[i]
for n,radius in enumerate(generate_A054994()):
    if n==34:
        print(radius)
        break # print the first 35 elements
    print(radius, end=", ")
# _Günter Rote_, Sep 12 2023
```
