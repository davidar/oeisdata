# Lexicographically smallest permutation of the natural numbers, such that a\(n\)\+n and a\(n\)\+n\+1 are both composite numbers\.
https://oeis.org/A260933
## JSON
```JSON
[7, 6, 5, 4, 3, 2, 1, 12, 11, 10, 9, 8, 13, 18, 17, 16, 15, 14, 19, 24, 23, 22, 21, 20, 25, 28, 27, 26, 33, 32, 31, 30, 29, 34, 39, 38, 37, 36, 35, 40, 43, 42, 41, 46, 45, 44, 47, 50, 49, 48, 53, 52, 51, 56, 55, 54, 57, 58, 59, 60, 61, 62, 65, 64, 63, 66, 67]
```
## Mathematica
```Mathematica
a[n_]:=a[n]=(k=1;While[PrimeQ[k+n]||PrimeQ[k+n+1]||MemberQ[Array[a,n-1],k],k++];k);Array[a,100] (* _Giorgos Kalogeropoulos_, Jul 06 2021 *)
```
## Haskell
```Haskell
import Data.List (delete)
a260933 n = a260933_list !! (n-1)
a260933_list = f 1 [1..] where
   f x zs = g zs where
     g (y:ys) = if a010051' (x + y) == 0 && a010051' (x + y + 1) == 0
                   then y : f (x + 1) (delete y zs) else g ys
```
## Python
```Python
from sympy import isprime
def composite(n): return n > 1 and not isprime(n)
def aupton(terms):
    alst, aset = [], set()
    for n in range(1, terms+1):
        an = 1
        while True:
            while an in aset: an += 1
            if composite(an+n) and composite(an+n+1): break
            an += 1
        alst, aset = alst + [an], aset | {an}
    return alst
print(aupton(67)) # _Michael S. Branicky_, Jul 06 2021
```
