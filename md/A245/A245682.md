# Numbers x whose digits can be permuted to produce more than a single multiple of x\.
https://oeis.org/A245682
## JSON
```JSON
[123876, 142857, 153846, 230769, 285714, 1028574, 1218753, 1238760, 1239876, 1246878, 1294857, 1402857, 1420785, 1425897, 1428507, 1428570, 1428597, 1428705, 1429857, 1485792, 1492857, 1538460, 1539846, 1570284, 1584297, 2300769, 2307690, 2307699, 2309769, 2857014, 2857140, 2859714, 2985714, 10028574, 10178649]
```
## Maple
```Maple
P:=proc(q) local a,b,c,i,j,k,n,t; for n from 1 to q do a:=n; b:=[];
while a>0 do b:=[a mod 10,op(b)]; a:=trunc(a/10); od;
t:=0; for i from 2 to 9 do a:=i*n; c:=[];
while a>0 do c:=[a mod 10,op(c)]; a:=trunc(a/10); od;
if sort(b)=sort(c) then t:=t+1; fi; if t>1 then print(n); break;
fi; od; od; end: P(10^10);
# Alternative
N:= 10: # get a(1) to a(N)
count:= 0:
for x from 10 while count < N do
  M:= 10^(ilog10(x)+1)-1;
  L:= sort(convert(x,base,10));
  mults:= 0;
  for i from 2 to floor(M/x) do
    Lp:= sort(convert(i*x,base,10));
    if Lp = L then
      mults:= mults+1;
      if mults = 2 then
        count:= count+1;
        A[count]:= x;
        print(x);
        break;
      fi
    fi
   od
od:
seq(A[i],i=1..count); # _Robert Israel_, Jul 29 2014
```
## Python
```Python
import itertools
from itertools import permutations
for n in range(1,10**8):
..plist = list(permutations(str(n)))
..count = 0
..lst = []
..for i in plist:
....num = ''
....for j in range(len(i)):
......num += i[j]
....if int(num)%n==0 and int(num)/n > 1:
......if int(num) not in lst:
........lst.append(int(num))
........count += 1
..if count > 1:
....print(n,end=', ') # _Derek Orr_, Jul 29 2014
```
## PARI
```PARI
for(n=1,10^8,d=vecsort(digits(n));p=0;for(k=2,9,dd=vecsort(digits(n*k));if(d==dd,p++));if(p>1,print1(n,", "))) \\ faster program _Derek Orr_, Jul 29 2014
```
