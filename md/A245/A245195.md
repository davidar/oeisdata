# a\(n\) \= 2^A014081\(n\)\.
https://oeis.org/A245195
## JSON
```JSON
[1, 1, 1, 2, 1, 1, 2, 4, 1, 1, 1, 2, 2, 2, 4, 8, 1, 1, 1, 2, 1, 1, 2, 4, 2, 2, 2, 4, 4, 4, 8, 16, 1, 1, 1, 2, 1, 1, 2, 4, 1, 1, 1, 2, 2, 2, 4, 8, 2, 2, 2, 4, 2, 2, 4, 8, 4, 4, 4, 8, 8, 8, 16, 32, 1, 1, 1, 2, 1, 1, 2, 4, 1, 1, 1, 2, 2, 2, 4, 8, 1, 1, 1, 2, 1, 1, 2, 4, 2, 2, 2, 4, 4, 4, 8, 16, 2, 2, 2, 4, 2]
```
## Maple
```Maple
# This Maple program applies more generally to a sequence where the recurrence across a block is as follows. The parameters to be set are the sequence G(0), G(1), G(2), ... (the final terms in the blocks), and the multiplier m.
# For n in the range 2^(k-1) <= n < 2^k, write n = 2^k-2^r+j, with 0 <= r <= k-1 and 0 <= j < 2^(r-1), and j=0 if r=0. Then
# (if j=0) a(2^k-2^r) = G(k-r-1),
# (if j>0) a(2^k-2^r+j) = m*G(k-r-1)*a(j).
# Since Maple gives its lists an offset of 1, it is necessary to add 1 to the arguments of G.
# For the present sequence, G(n)=2^n and m=1.
G:=[seq(2^n,n=0..30)];
m:=1;
f:=proc(n) option remember; global m,G; local k,r,j,np;
if n <= 2 then G[0+1] elif n=3 then G[1+1]
elif n=4 then G[0+1] elif n=5 then m*G[0+1] elif n=6 then G[1+1] elif n=7 then G[2+1]
else
   k:=1+floor(log[2](n)); np:=2^k-n;
   if np=1 then r:=0; j:=0; else r:=1+floor(log[2](np-1)); j:=2^r-np; fi;
   if j=0 then G[k-r-1+1]; else m*G[k-r-1+1]*f(j); fi;
fi;
end;
[seq(f(n),n=1..520)]:
# Setting G(n) = A083424(n) and m = 8 gives A245180. Setting G(n) = 2^n and m = 2 gives A048896.
A245195:=n->add(binomial(n,2*k)*binomial(n,k) mod 2, k=0..floor(n/2)): seq(A245195(n), n=0..200); # _Wesley Ivan Hurt_, Nov 01 2016
```
## Mathematica
```Mathematica
Table[Sum[Mod[Binomial[n, 2 k] Binomial[n, k], 2], {k, 0, n}], {n, 0, 85}] (* _Michael De Vlieger_, Oct 21 2016 *)
```
## PARI
```PARI
a(n) = 2^hammingweight(bitand(n, n>>1)) \\ _Charles R Greathouse IV_, Jul 16 2016
```
```PARI
a(n) = sum(k=0, n, binomial(n, 2*k)*binomial(n,k) % 2); \\ _Michel Marcus_, Oct 21 2016
```
## Python
```Python
from __future__ import division
def A277560(n):
    return sum(int(not (~n & 2*k) | (~n & k)) for k in range(n//2+1))
```
```Python
def A245195(n): return 1<<(n&(n>>1)).bit_count() # _Chai Wah Wu_, Feb 11 2023
```
