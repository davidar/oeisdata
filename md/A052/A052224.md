# Numbers whose sum of digits is 10\.
https://oeis.org/A052224
## JSON
```JSON
[19, 28, 37, 46, 55, 64, 73, 82, 91, 109, 118, 127, 136, 145, 154, 163, 172, 181, 190, 208, 217, 226, 235, 244, 253, 262, 271, 280, 307, 316, 325, 334, 343, 352, 361, 370, 406, 415, 424, 433, 442, 451, 460, 505, 514, 523, 532, 541, 550, 604, 613, 622, 631, 640]
```
## Maple
```Maple
sd := proc (n) options operator, arrow: add(convert(n, base, 10)[j], j = 1 .. nops(convert(n, base, 10))) end proc: a := proc (n) if sd(n) = 10 then n else end if end proc: seq(a(n), n = 1 .. 800); # _Emeric Deutsch_, Jan 16 2009
```
## Mathematica
```Mathematica
Union[Flatten[Table[FromDigits /@ Permutations[PadRight[s, 7]], {s, Rest[IntegerPartitions[10]]}]]] (* _T. D. Noe_, Mar 08 2013 *)
```
```Mathematica
Select[Range[1000], Total[IntegerDigits[#]] == 10 &] (* _Vincenzo Librandi_, Mar 10 2013 *)
```
## Magma
```Magma
[n: n in [1..1000] | &+Intseq(n) eq 10 ]; // _Vincenzo Librandi_, Mar 10 2013
```
## Haskell
```Haskell
a052224 n = a052224_list !! (n-1)
a052224_list = filter ((== 10) . a007953) [0..]
-- _Reinhard Zumkeller_, Jul 17 2014
```
## PARI
```PARI
isok(n) = sumdigits(n) == 10; \\ _Michel Marcus_, Dec 28 2015
```
```PARI
\\ This algorithm needs a modified binomial.
C(n, k)=if(n>=k, binomial(n, k), 0)
\\ ways to roll s-q with q dice having sides 0 through n - 1.
b(s, q, n)=if(s<=q*(n-1), s+=q; sum(i=0, q-1, (-1)^i*C(q, i)*C(s-1-n*i, q-1)), 0)
\\ main algorithm; this program applies to all sequences of the form "Numbers whose sum of digits is m."
a(n,{m=10}) = {my(q); q = 2; while(b(m, q, 10) < n, q++); q--; s = m; os = m; r=0; while(q, if(b(s, q, 10) < n, n-=b(s, q, 10); s--, r+=(os-s)*10^(q); os = s; q--)); r+= s; r}
\\ _David A. Corneth_, Jun 05 2016
```
## Python
```Python
from sympy.utilities.iterables import multiset_permutations
def auptodigs(maxdigits, b=10, sod=10): # works for any base, sum-of-digits
    alst = [sod] if 0 <= sod < b else []
    nzdigs = [i for i in range(1, b) if i <= sod]
    nzmultiset = []
    for d in range(1, b):
        nzmultiset += [d]*(sod//d)
    for d in range(2, maxdigits + 1):
        fullmultiset = [0]*(d-1-(sod-1)//(b-1)) + nzmultiset
        for firstdig in nzdigs:
            target_sum, restmultiset = sod - int(firstdig), fullmultiset[:]
            restmultiset.remove(firstdig)
            for p in multiset_permutations(restmultiset, d-1):
              if sum(p) == target_sum:
                  alst.append(int("".join(map(str, [firstdig]+p)), b))
                  if p[0] == target_sum:
                      break
    return alst
print(auptodigs(4)) # _Michael S. Branicky_, Sep 14 2021
```
```Python
def A052224(N = 19):
    """Return a generator of the sequence of all integers >= N with the same
    digit sum as N."""
    while True:
        yield N
        N = A228915(N) # skip to next larger integer with the same digit sum
a = A052224(); [next(a) for _ in range(50)] # _M. F. Hasler_, Mar 16 2022
```
