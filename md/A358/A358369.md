# Euler transform of 2^floor\(n/2\), \(A016116\)\.
https://oeis.org/A358369
## JSON
```JSON
[1, 1, 3, 5, 12, 20, 43, 73, 146, 250, 475, 813, 1499, 2555, 4592, 7800, 13761, 23253, 40421, 67963, 116723, 195291, 332026, 552882, 932023, 1544943, 2585243, 4267081, 7094593, 11662769, 19281018, 31575874, 51937608, 84753396, 138772038, 225693778, 368017636]
```
## Maple
```Maple
BinaryRecurrenceSequence := proc(b, c, u0:=0, u1:=1) local u;
u := proc(n) option remember; if n < 2 then return [u0, u1][n + 1] fi;
b*u(n - 1) + c*u(n - 2) end; u end:
EulerTransform := proc(a) local b;
b := proc(n) option remember; if n = 0 then return 1 fi; add(add(d * a(d),
d = NumberTheory:-Divisors(j)) * b(n-j), j = 1..n) / n end; b end:
a := EulerTransform(BinaryRecurrenceSequence(0, 2, 1)): seq(a(n), n=0..36);
```
## Sage
```Sage
# uses[EulerTransform from A166861]
b = BinaryRecurrenceSequence(0, 2, 1)
a = EulerTransform(b)
print([a(n) for n in range(37)])
```
## Python
```Python
from typing import Callable
from functools import cache
from sympy import divisors
def BinaryRecurrenceSequence(b:int, c:int, u0:int=0, u1:int=1) -> Callable:
    @cache
    def u(n: int) -> int:
        if n < 2:
            return [u0, u1][n]
        return b * u(n - 1) + c * u(n - 2)
    return u
def EulerTransform(a: Callable) -> Callable:
    @cache
    def b(n: int) -> int:
        if n == 0:
            return 1
        s = sum(sum(d * a(d) for d in divisors(j)) * b(n - j)
            for j in range(1, n + 1))
        return s // n
    return b
b = BinaryRecurrenceSequence(0, 2, 1)
a = EulerTransform(b)
print([a(n) for n in range(37)])
```
