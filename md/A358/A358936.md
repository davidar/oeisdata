# Numbers k such that for some r we have phi\(1\) \+ \.\.\. \+ phi\(k \- 1\) \= phi\(k \+ 1\) \+ \.\.\. \+ phi\(k \+ r\), where phi\(i\) \= A000010\(i\)\.
https://oeis.org/A358936
## JSON
```JSON
[3, 4, 6, 38, 40, 88, 244, 578, 581, 602, 1663, 2196, 10327, 17358, 28133, 36163, 42299, 123556, 149788, 234900, 350210, 366321, 620478, 694950, 869880, 905807, 934286, 1907010, 2005592, 5026297, 7675637, 11492764, 12844691, 14400214, 15444216, 18798939, 20300872]
```
## Mathematica
```Mathematica
With[{m = 30000},phi = EulerPhi[Range[m]]; s = Accumulate[phi]; Select[Range[2, m], MemberQ[s, 2*s[[#]] - phi[[#]]] &]] (* _Amiram Eldar_, Dec 07 2022 *)
```
## Python
```Python
from sympy import totient as phi
from itertools import count, islice
def f(n): # function we wish to "balance"
    return phi(n)
def agen(): # generator of terms
    s, sset, i = [0, f(1), f(1)+f(2)], set(), 3
    for k in count(2):
        target = s[k-1] + s[k]
        while s[-1] < target:
            fi = f(i); nexts = s[-1] + fi; i += 1
            s.append(nexts); sset.add(nexts)
        if target in sset: yield k
print(list(islice(agen(), 17))) # _Michael S. Branicky_, Dec 07 2022
```
## PARI
```PARI
upto(n) = {my(res = List(), lefttotal = 1, righttotal = 2, k = 2, nplusr = 3, sumf = 1, oldfk = 1); for(i = 1, n,  while(lefttotal > righttotal, nplusr++; righttotal+=f(nplusr) ); if(lefttotal == righttotal, listput(res, k)); lefttotal+=oldfk; k++; fk = f(k); righttotal-=fk; oldfk = fk ); res }
f(k) = eulerphi(k) \\ _David A. Corneth_, Dec 07 2022
```
