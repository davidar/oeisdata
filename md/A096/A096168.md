# Number of Abelian cubefree words over a 3\-letter alphabet\.
https://oeis.org/A096168
## JSON
```JSON
[1, 3, 9, 24, 66, 180, 468, 1206, 3150, 7998, 20124, 50520, 124044, 303906, 744870, 1790226, 4319322, 10432044, 24926934, 59570514, 142662384, 339247320, 807092274, 1920506232, 4543861644]
```
## Python
```Python
from itertools import product
def anagrams(b1, b2, b3):
    return sorted(b1) == sorted(b2) == sorted(b3)
def acf(s):
    for l in range(1, len(s)//3 + 1):
      for i in range(len(s) - 3*l + 1):
          if anagrams(s[i:i+l], s[i+l:i+2*l], s[i+2*l:i+3*l]): return False
    return True
def a(n):
    if n == 0: return 1
    return 3*sum(acf("0"+"".join(w)) for w in product("012", repeat=n-1))
print([a(n) for n in range(14)]) # _Michael S. Branicky_, Jul 11 2021
```
```Python
# faster, but > memory, version for initial segment of sequence
def anagrams(b1, b2, b3): return sorted(b1) == sorted(b2) == sorted(b3)
def iacf(s): # incrementally abelian cubefree
    for l in range(1, len(s)//3 + 1):
        if anagrams(s[-3*l:-2*l], s[-2*l:-l], s[-l:]): return False
    return True
def aupton(nn, verbose=False):
    alst, acfs = [1], set("0")
    for n in range(1, nn+1):
        an = 3*len(acfs)
        acfsnew = set(c+i for c in acfs for i in "012" if iacf(c+i))
        alst, acfs = alst+[an], acfsnew
        if verbose: print(n, an)
    return alst
print(aupton(14)) # _Michael S. Branicky_, Jul 22 2021
```
