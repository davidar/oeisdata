# The least k whose n\-th root contains k as a string of digits to the immediate right of the decimal point \(excluding leading zeros\)\.
https://oeis.org/A096257
## JSON
```JSON
[8, 2, 3, 633, 19703, 89, 69, 56, 46, 39, 33, 29, 25, 22, 20, 18, 16, 14, 13, 12, 11, 10, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 138, 133, 128, 124, 120, 116, 113, 109, 106, 103, 100, 97, 95, 92, 90, 87, 85, 83, 81, 79, 77, 75, 74, 72, 70, 69, 67, 66, 65, 63, 62, 61, 59, 58, 57]
```
## Mathematica
```Mathematica
f[k_, n_] := Block[{l = Floor[ Log[10, k] + 1], rd = RealDigits[ k^(1/n), 10, 24], id = IntegerDigits[k]}, rdd = Drop[ rd[[1]], rd[[2]]]; While[ rdd[[1]] == 0, rdd = Drop[rdd, 1]]; Take[rdd, l] == id]; g[n_] := Block[{k = 2}, While[IntegerQ[k^(1/n)] || f[k, n] == False, k++ ]; k]; Table[ g[n], {n, 2, 72}]
```
## Python
```Python
import re
from sympy import perfect_power
from decimal import *
getcontext().prec = 24
def lzs(s): return len(s) - 2 - len(s[2:].lstrip('0')) # # of leading zeros
def cond(sk, sroot, k, n): # is condition true, with precision verification
    if perfect_power(k, [n]): return False # decimal part should be all 0's
    assert lzs(sroot) + len(sk) < len(sroot) - 3, (n, "increase precision")
    return re.match("0.0*"+sk, sroot)
def a(n):
    k, power = 1, Decimal(1)/Decimal(n)
    rootk, sk = Decimal(k)**power, str(k)
    while not cond(sk, str(rootk - int(rootk)), k, n):
        k += 1
        rootk, sk = Decimal(k)**power, str(k)
    return k
print([a(n) for n in range(2, 73)]) # _Michael S. Branicky_, Aug 02 2021
```
