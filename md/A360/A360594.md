# a\(n\) is the maximum number of locations 0\.\.n\-1 which can be visited in a single path starting from i\=n\-1, where jumps from location i to i \+\- a\(i\) are permitted \(within 0\.\.n\-1\) and each location can be visited up to 2 times\.
https://oeis.org/A360594
## JSON
```JSON
[0, 2, 1, 2, 4, 3, 8, 1, 2, 2, 4, 2, 8, 5, 4, 6, 13, 14, 14, 13, 13, 16, 22, 3, 17, 16, 20, 13, 13, 24, 22, 15, 24, 15, 14, 17, 14, 4, 15, 18, 23, 26, 28, 13, 16, 30, 28, 14, 15, 17, 16, 19, 16, 33, 18, 33, 32, 35, 39, 38, 40, 38, 39, 39, 36, 39, 38, 39, 41, 52]
```
## Python
```Python
def A(lastn,times=2,mode=0):
  a,n=[0],0
  while n<lastn:
    d,i,v,o,g,r=[[n]],0,1,[],0,0
    while len(d)>0:
      if len(d[-1])>v: v,o=len(d[-1]),d[-1][:]
      if d[-1][-1]-a[d[-1][-1]]>=0:
        if d[-1].count(d[-1][-1]-a[d[-1][-1]])<times:g=1
      if d[-1][-1]+a[d[-1][-1]]<=n:
        if d[-1].count(d[-1][-1]+a[d[-1][-1]])<times:
          if g>0: d.append(d[-1][:])
          d[-1].append(d[-1][-1]+a[d[-1][-1]])
          r=1
      if g>0:
        if r>0: d[-2].append(d[-2][-1]-a[d[-2][-1]])
        else: d[-1].append(d[-1][-1]-a[d[-1][-1]])
        r=1
      if r==0: d.pop()
      r,g=0,0
    a.append(v)
    n+=1
    if mode==0: print(n,a[n])
    if mode>0:
      u,q=0,[]
      while u<len(o):
        q.append(a[o[u]])
        u+=1
      print(n,a[n],q,o)
  return a
```
