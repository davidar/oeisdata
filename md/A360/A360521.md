# a\(0\) \= 0; for n \> 0, a\(n\) is the smallest positive number not occurring earlier such that neither the binary string a\(n\-1\) \+ a\(n\) nor the same string reversed appear in the binary string concatenation of a\(0\)\.\.a\(n\-1\)\.
https://oeis.org/A360521
## JSON
```JSON
[0, 1, 2, 3, 4, 5, 10, 6, 9, 7, 17, 15, 18, 14, 19, 13, 20, 12, 21, 11, 22, 26, 8, 24, 27, 37, 28, 23, 25, 39, 29, 35, 30, 34, 31, 33, 32, 36, 41, 44, 43, 42, 38, 62, 57, 70, 58, 69, 59, 68, 60, 67, 61, 66, 63, 64, 65, 71, 76, 52, 84, 72, 56, 80, 48, 88, 40, 96, 51, 77, 83, 45, 91, 81, 47, 89, 86]
```
## Mathematica
```Mathematica
nn = 76; c[_] = False; j = a[0] = 0; u = 1; w = "0"; Do[k = u; While[Or[c[k], StringContainsQ[w, Set[v, IntegerString[j + k, 2]]], StringContainsQ[w, StringReverse[v]]], k++]; Set[{a[n], c[k]}, {k, True}]; Set[{j, w}, {k, w <> IntegerString[k, 2]}]; If[k == u, While[c[u], u++]], n]; Array[a, nn + 1, 0] (* _Michael De Vlieger_, Feb 15 2023 *)
```
## Python
```Python
from itertools import islice
def agen(): # generator of terms
    an, astr, aset, mink = 0, "", set(), 1
    while True:
        yield an
        s = bin(an)[2:]
        astr += s
        k = mink
        while k in aset or (t:=bin(an+k)[2:]) in astr or t[::-1] in astr:
            k += 1
        an = k
        aset.add(an)
        while mink in aset: mink += 1
print(list(islice(agen(), 80))) # _Michael S. Branicky_, Feb 10 2023
```
