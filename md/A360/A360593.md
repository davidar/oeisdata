# Each term a\(i\) can reach a\(i\+a\(i\)\) and a\(i\-a\(i\)\) if these terms exist\. a\(n\) is the greatest number of terms among a\(1\.\.n\-1\) that can be reached by starting at a\(n\-1\) and visiting no term more than once; a\(0\)\=0\. See example\.
https://oeis.org/A360593
## JSON
```JSON
[0, 1, 2, 2, 4, 2, 6, 2, 7, 5, 6, 6, 9, 10, 10, 6, 8, 7, 9, 8, 11, 8, 12, 14, 12, 14, 19, 16, 19, 14, 14, 16, 14, 21, 14, 16, 21, 14, 14, 16, 14, 18, 14, 16, 21, 21, 19, 21, 22, 22, 21, 23, 24, 24, 29, 29, 22, 26, 24, 28, 24, 26, 31, 24, 31, 34, 24, 30, 34, 29, 39]
```
## Python
```Python
def A(lastn,times=1,mode=0):
  a,n=[0],0
  while n<lastn:
    d,i,v,o,g,r=[[n]],0,1,[],0,0
    while len(d)>0:
      if len(d[-1])>v: v,o=len(d[-1]),d[-1][:]
      if d[-1][-1]-a[d[-1][-1]]>=0:
        if d[-1].count(d[-1][-1]-a[d[-1][-1]])<times:g=1
      if d[-1][-1]+a[d[-1][-1]]<=n:
        if d[-1].count(d[-1][-1]+a[d[-1][-1]])<times:
          if g>0: d.append(d[-1][:])
          d[-1].append(d[-1][-1]+a[d[-1][-1]])
          r=1
      if g>0:
        if r>0: d[-2].append(d[-2][-1]-a[d[-2][-1]])
        else: d[-1].append(d[-1][-1]-a[d[-1][-1]])
        r=1
      if r==0:d.pop()
      r,g=0,0
    a.append(v)
    n+=1
    if mode==0: print(n,a[n])
    if mode>0:
      u,q=0,[]
      while u<len(o):
        q.append(a[o[u]])
        u+=1
      print(n,a[n],q,o)
  return a
```
