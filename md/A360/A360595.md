# a\(n\) is the maximum number of locations 1\.\.n\-1 which can be visited in a single path starting from i \= n\-1, where jumps from location i to i \+\- a\(i\) are permitted \(within 1\.\.n\-1\) and a term can be visited up to three times\.
https://oeis.org/A360595
## JSON
```JSON
[0, 3, 1, 2, 2, 12, 1, 2, 2, 4, 2, 10, 15, 1, 2, 2, 4, 2, 10, 20, 1, 2, 2, 4, 2, 10, 13, 8, 2, 10, 2, 15, 7, 15, 25, 17, 53, 1, 2, 2, 4, 2, 10, 65, 1, 2, 2, 4, 2, 10, 13, 8, 2, 10, 2, 15, 7, 15, 72, 1, 2, 2, 4, 2, 10, 24, 18, 52]
```
## Python
```Python
def A(lastn,times=3,mode=0):
  a,n=[0],0
  while n<lastn:
    d,i,v,o,g,r=[[n]],0,1,[],0,0
    while len(d)>0:
      if len(d[-1])>v: v,o=len(d[-1]),d[-1][:]
      if d[-1][-1]-a[d[-1][-1]]>=0:
        if d[-1].count(d[-1][-1]-a[d[-1][-1]])<times:g=1
      if d[-1][-1]+a[d[-1][-1]]<=n:
        if d[-1].count(d[-1][-1]+a[d[-1][-1]])<times:
          if g>0: d.append(d[-1][:])
          d[-1].append(d[-1][-1]+a[d[-1][-1]])
          r=1
      if g>0:
        if r>0: d[-2].append(d[-2][-1]-a[d[-2][-1]])
        else: d[-1].append(d[-1][-1]-a[d[-1][-1]])
        r=1
      if r==0: d.pop()
      r,g=0,0
    a.append(v)
    n+=1
    if mode==0: print(n+1,a[n])
    if mode>0:
      u,q=0,[]
      while u<len(o):
        q.append(a[o[u]])
        u+=1
      print(n+1,a[n],q,o)
  return a
```
