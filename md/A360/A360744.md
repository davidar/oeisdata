# a\(n\) is the maximum number of locations 1\.\.n\-1 which can be reached starting from some location s, where jumps from location i to i \+\- a\(i\) are permitted \(within 1\.\.n\-1\); a\(1\)\=1\. See example\.
https://oeis.org/A360744
## JSON
```JSON
[1, 1, 2, 3, 4, 5, 5, 6, 6, 7, 7, 9, 10, 10, 10, 11, 11, 13, 14, 14, 14, 15, 15, 15, 15, 21, 21, 21, 22, 22, 22, 23, 23, 23, 23, 24, 24, 26, 27, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 32, 32, 32, 32, 33, 33, 35, 35, 41, 42, 42, 42, 43, 43, 43, 44, 44, 45, 45, 46, 46, 46, 46, 46, 46, 47, 47, 49, 49, 51, 51, 51]
```
## Python
```Python
def A(lastn,mode=0):
  a,n,t=[1],0,1
  while n<lastn:
    p,v=0,1
    while p<=n:
      d,g,r,rr=[[p]],0,0,[p]
      while len(d)>0:
        if not d[-1][-1] in rr:rr.append(d[-1][-1])
        if d[-1][-1]-a[d[-1][-1]]>=0:
          if d[-1].count(d[-1][-1]-a[d[-1][-1]])<t:g=1
        if d[-1][-1]+a[d[-1][-1]]<=n:
          if d[-1].count(d[-1][-1]+a[d[-1][-1]])<t:
            if g>0: d.append(d[-1][:])
            d[-1].append(d[-1][-1]+a[d[-1][-1]])
            r=1
        if g>0:
          if r>0: d[-2].append(d[-2][-1]-a[d[-2][-1]])
          else: d[-1].append(d[-1][-1]-a[d[-1][-1]])
          r=1
        if r==0:d.pop()
        r,g=0,0
      if v<len(rr):v=len(rr)
      p+=1
    a.append(v)
    n+=1
    print(n+1,a[n])
    if mode>0: print(a)
  return a ## _S. Brunner_, Feb 19 2023
```
