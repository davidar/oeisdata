# a\(n\) is the maximum number of locations 1\.\.n\-1 which can be reached starting from a\(n\-1\), where jumps from location i to i \+\- a\(i\) are permitted \(within 1\.\.n\-1\); a\(1\)\=1\. See example\.
https://oeis.org/A360746
## JSON
```JSON
[1, 1, 2, 3, 4, 4, 5, 5, 5, 7, 8, 8, 8, 9, 9, 12, 10, 10, 12, 10, 12, 13, 13, 13, 16, 14, 14, 16, 17, 17, 17, 18, 18, 24, 25, 25, 25, 26, 27, 27, 27, 27, 28, 28, 30, 28, 33, 28, 29, 30, 30, 30, 33, 31, 31, 31, 32, 32, 33, 33, 31, 31, 32, 33, 33, 35, 33, 37]
```
## Python
```Python
def A(lastn,mode=0):
  a,n,t=[1],0,1
  while n<lastn:
    d, g, r, rr=[[n]], 0, 0, [n]
    while len(d)>0:
      if not d[-1][-1] in rr:rr.append(d[-1][-1])
      if d[-1][-1]-a[d[-1][-1]]>=0:
        if d[-1].count(d[-1][-1]-a[d[-1][-1]])<t:g=1
      if d[-1][-1]+a[d[-1][-1]]<=n:
        if d[-1].count(d[-1][-1]+a[d[-1][-1]])<t:
          if g>0: d.append(d[-1][:])
          d[-1].append(d[-1][-1]+a[d[-1][-1]])
          r=1
      if g>0:
        if r>0: d[-2].append(d[-2][-1]-a[d[-2][-1]])
        else: d[-1].append(d[-1][-1]-a[d[-1][-1]])
        r=1
      if r==0:d.pop()
      r,g=0,0
    a.append(len(rr))
    n+=1
    print(n+1,a[n])
    if mode>0: print(a)
  return a  # _S. Brunner_, Feb 26 2023
```
