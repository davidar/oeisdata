# Numbers n such that prevprime\(2^n\) AND nextprime\(2^n\) \= 1, where AND is the bitwise AND operator\.
https://oeis.org/A214415
## JSON
```JSON
[2, 4, 6, 8, 12, 15, 16, 23, 25, 30, 37, 53, 55, 57, 67, 75, 76, 81, 82, 84, 95, 108, 129, 132, 135, 139, 143, 155, 160, 163, 180, 181, 188, 192, 203, 204, 210, 222, 244, 263, 273, 277, 280, 287, 289, 295, 297, 308, 315, 319, 325, 330, 341, 367, 370, 393, 394, 406]
```
## Mathematica
```Mathematica
ba1Q[n_]:=Module[{c=2^n},BitAnd[NextPrime[c],NextPrime[c,-1]]==1]; Select[ Range[ 450],ba1Q] (* _Harvey P. Dale_, Dec 25 2012 *)
```
## Java
```Java
import java.math.BigInteger;
public class A214415 {
  public static void main (String[] args) {
    BigInteger b1 = BigInteger.valueOf(1);
    BigInteger b2 = BigInteger.valueOf(2);
    for (int n=2; ; n++) {
      BigInteger pwr = b1.shiftLeft(n);
      BigInteger pm  = pwr.subtract(b1);
      BigInteger pp  = pwr.add(b1);
      while (true) {
        if (pm.isProbablePrime(2)) {
            if (pm.isProbablePrime(80)) break;
        }
        pm  = pm.subtract(b2);
      }
      while (true) {
        if (pp.isProbablePrime(2)) {
            if (pp.isProbablePrime(80)) break;
        }
        pp  = pp.add(b2);
      }
      if (pm.and(pp).equals(b1)) {
        System.out.printf("%d, ",n);
      }
    }
  }
}
```
## PARI
```PARI
{ for (n=2,1000,  N = 2^n;
    p1 = precprime(N-1);
    p2 = nextprime(N+1);
    ba = bitand(p1, p2);
    if ( bitand( ba, ba-1 ) == 0, print1(n,", "));
); }
/* _Joerg Arndt_, Aug 16 2012 */
```
## Python
```Python
from itertools import islice
from sympy import prevprime, nextprime
def A214415_gen(): # generator of terms
    n, m = 2, 4
    while True:
        if prevprime(m)&nextprime(m) == 1:
            yield n
        n += 1
        m *= 2
A214415_list = list(islice(A214415_gen(),20)) # _Chai Wah Wu_, Oct 16 2023
```
