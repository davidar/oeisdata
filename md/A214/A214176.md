# Sum of the 8 nearest neighbors of n in a spiral with positive integers\.
https://oeis.org/A214176
## JSON
```JSON
[44, 58, 72, 62, 96, 82, 120, 94, 104, 152, 120, 130, 184, 146, 144, 164, 224, 180, 176, 198, 264, 214, 208, 216, 240, 312, 256, 248, 256, 282, 360, 298, 288, 296, 304, 332, 416, 348, 336, 344, 352, 382, 472, 398, 384, 392, 400, 408, 440, 536, 456, 440]
```
## Mathematica
```Mathematica
step=15; (f=Join[{12,18,24,6,32,10,40,6},Flatten@Table[{Table[0,k], s=10+2i,56+8i,s},{k,0,step},{i,2k-1,2k}]])+8Range@Length@f+24 (* _Giorgos Kalogeropoulos_, Sep 23 2023 *)
```
## Python
```Python
SIZE=11  # must be odd
grid = [0] * (SIZE*SIZE)
posX = posY = SIZE//2
grid[posY*SIZE+posX]=1
n = 2
saveX = [0]* (SIZE*SIZE+1)
saveY = [0]* (SIZE*SIZE+1)
saveX[1]=posX
saveY[1]=posY
def walk(stepX,stepY,chkX,chkY):
  global posX, posY, n
  while 1:
    posX+=stepX
    posY+=stepY
    grid[posY*SIZE+posX]=n
    saveX[n]=posX
    saveY[n]=posY
    n+=1
    if posX+posY==0 or grid[(posY+chkY)*SIZE+posX+chkX]==0:
        return
while 1:
    walk(0,-1, 1, 0)    # up
    if posX+posY==0:
        break
    walk(1, 0, 0, 1)    # right
    walk(0, 1,-1, 0)    # down
    walk(-1,0, 0,-1)    # left
for n in range(1,(SIZE-2)*(SIZE-2)+1):
    posX = saveX[n]
    posY = saveY[n]
    k = grid[(posY-1)*SIZE+posX] + grid[(posY+1)*SIZE+posX]
    k+= grid[(posY-1)*SIZE+posX-1] + grid[(posY-1)*SIZE+posX+1]
    k+= grid[(posY+1)*SIZE+posX-1] + grid[(posY+1)*SIZE+posX+1]
    print k+grid[posY*SIZE+posX-1] + grid[posY*SIZE+posX+1],
```
