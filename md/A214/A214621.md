# Numbers n such that at least one other integer m exists with the same smallest and same largest prime factors, and same multisets of decimal and binary digits as n\.
https://oeis.org/A214621
## JSON
```JSON
[1080, 1260, 1800, 2016, 2673, 3024, 3267, 3402, 4032, 4500, 4653, 4950, 5346, 5400, 5670, 5757, 5940, 6048, 6345, 6534, 6804, 7056, 7560, 7575, 8064, 11084, 11542, 12654, 12915, 13026, 13068, 13260, 13860, 14018, 14490, 14652, 14904, 15124, 15129, 16032, 16320]
```
## Maple
```Maple
Res:= {}:
for n from 1 to 2^16-1 do
  f:= numtheory:-factorset(n);
  v:= [min(f),max(f),ilog2(n), convert(convert(n,base,2),`+`),sort(convert(n,base,10))];
  if assigned(R[v]) then
     Res:= Res union {n, R[v]}
  else
     R[v]:= n
  fi
od:
sort(convert(Res,list)); # _Robert Israel_, Sep 28 2018
```
## Python
```Python
# primes = [2...99991]
# ~15 minutes
TOP = 100000
smallest = [0]*TOP
largest  = [0]*TOP
decimal = [0]*TOP
binary  = [0]*TOP
flags = [0]*TOP
for n in range(1,TOP):
    curSm = curLa = curDec = curBin = 0
    t = b = d = n
    while b:
        curBin += 1000**( b&1 )
        b /= 2
    while d:
        curDec += 10**( d%10 )
        d /= 10
    for p in primes:
        if t%p==0:
            if curSm==0:
                curSm = p
            curLa = p
            t/=p
            while t%p==0:
                t/=p
            if t==1:
                break
    binary[n] = curBin
    decimal[n] = curDec
    smallest[n] = curSm
    largest[n]  = curLa
    for k in range(1,n):
        if smallest[k]==curSm and largest[k]==curLa:
            if decimal[k]==curDec and binary[k]==curBin:
                flags[k]+=1
                flags[n]+=1
for n in range(1,TOP):
    if flags[n]>0:
        print n,
```
