# Next perfect power having the same least root of n\-th perfect power, A001597\.
https://oeis.org/A076405
## JSON
```JSON
[1, 8, 16, 27, 32, 125, 81, 64, 216, 343, 128, 243, 1000, 1331, 625, 256, 1728, 2197, 2744, 1296, 3375, 729, 512, 4913, 5832, 2401, 6859, 8000, 9261, 10648, 1024, 12167, 13824, 3125, 17576, 2187, 21952, 24389, 27000, 29791, 10000, 2048, 35937, 39304]
```
## Mathematica
```Mathematica
ppQ[n_] := GCD @@ Last /@ FactorInteger@# > 1; f[n_] := Block[{fi = Transpose@ FactorInteger@ n}, fi2 = fi[[2]]; Times @@ (fi[[1]]^(fi[[2]] (1 + 1/GCD @@ fi[[2]])))]; lst = Join[{1}, Select[ Range@ 1848, ppQ@# &]]; f /@ lst (* _Robert G. Wilson v_, Aug 03 2008 *)
```
## Haskell
```Haskell
a076405 n = a076405_list !! (n-1)
a076405_list = 1 : f (tail $ zip a001597_list a025478_list) where
   f ((p, r) : us) = g us where
     g ((q, r') : vs) = if r' == r then q : f us else g vs
-- _Reinhard Zumkeller_, Mar 11 2014
```
## Python
```Python
from math import gcd
from sympy import mobius, integer_nthroot, factorint
def A076405(n):
    if n == 1: return 1
    def f(x): return int(n-2+x+sum(mobius(k)*(integer_nthroot(x,k)[0]-1) for k in range(2,x.bit_length())))
    kmin, kmax = 1,2
    while f(kmax) >= kmax:
        kmax <<= 1
    while True:
        kmid = kmax+kmin>>1
        if f(kmid) < kmid:
            kmax = kmid
        else:
            kmin = kmid
        if kmax-kmin <= 1:
            break
    return kmax*integer_nthroot(kmax, gcd(*factorint(kmax).values()))[0] # _Chai Wah Wu_, Aug 13 2024
```
