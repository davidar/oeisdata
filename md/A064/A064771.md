# Let S\(n\) \= set of divisors of n, excluding n; sequence gives n such that there is a unique subset of S\(n\) that sums to n\.
https://oeis.org/A064771
## JSON
```JSON
[6, 20, 28, 78, 88, 102, 104, 114, 138, 174, 186, 222, 246, 258, 272, 282, 304, 318, 354, 366, 368, 402, 426, 438, 464, 474, 490, 496, 498, 534, 572, 582, 606, 618, 642, 650, 654, 678, 748, 762, 786, 822, 834, 860, 894, 906, 940, 942, 978, 1002, 1014, 1038]
```
## Maple
```Maple
filter:= proc(n)
  local P,x,d;
  P:= mul(x^d+1, d = numtheory:-divisors(n) minus {n});
  coeff(P,x,n) = 1
end proc:
select(filter, [$1..2000]); # _Robert Israel_, Sep 25 2024
```
## Mathematica
```Mathematica
okQ[n_]:= Module[{d=Most[Divisors[n]]}, SeriesCoefficient[Series[ Product[ 1+x^i, {i, d}], {x, 0, n}], n] == 1];Select[ Range[ 1100],okQ] (* _Harvey P. Dale_, Dec 13 2010 *)
```
## Haskell
```Haskell
a064771 n = a064771_list !! (n-1)
a064771_list = map (+ 1) $ elemIndices 1 a065205_list
-- _Reinhard Zumkeller_, Jan 21 2013
```
## Python
```Python
from sympy import divisors
def isok(n):
    dp = {0: 1}
    for d in divisors(n)[:-1]:
        u = {}
        for k in dp.keys():
            if (s := (d + k)) <= n:
                u[s] = dp.get(s, 0) + dp[k]
                if s == n and u[s] > 1:
                    return False
        for k,v in u.items():
            dp[k] = v
    return dp.get(n, 0) == 1
print([n for n in range(1, 1039) if isok(n)]) # _Dar√≠o Clavijo_, Sep 17 2024
```
