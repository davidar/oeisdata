# a\(n\) is the minimum size of a square integer grid allowing all triples of n points to form triangles of different areas\.
https://oeis.org/A303331
## JSON
```JSON
[0, 1, 1, 2, 4, 6, 9, 11, 15, 19]
```
## Python
```Python
def addNewAreas(plist, used_areas):
....# Attempt to add last point in plist. 'used_areas' contains all (areas*2)
....# between preplaced points and is updated
....m=len(plist)
....for i in range(m-2):
........for j in range(i+1,m-1):
............k=m-1
............p,q,r=plist[i],plist[j],plist[k]
............# Area = s/2 - using s enables us to use integers
............s=(p[0]*q[1]-p[1]*q[0]) + (q[0]*r[1]-q[1]*r[0]) + (r[0]*p[1]-r[1]*p[0])
............if s<0:
................s=-s
............if s in used_areas:
................return False # Area not unique
............else:
................used_areas[s]=True
....return True
def solveRecursively(n, L, plist, used_areas):
....m=len(plist)
....if m==n:
........#print plist (uncomment to show solution)
........return True
....newlist=plist+[None]
....if m>0:
........startidx=(L+1)*plist[m-1][0] + plist[m-1][1] + 1
....else:
........startidx=0
....for idx in range(startidx, (L+1)**2):
............newlist[m]=( idx/(L+1) , idx%(L+1) )
............newareas=dict(used_areas)
............if addNewAreas(newlist, newareas):
................if solveRecursively(n, L, newlist, newareas):
....................return True
....return False
def A303331(n):
....L=0
....while not solveRecursively(n, L, [], {0:True}):
........L+=1
....return L
def A303331_list(N):
....return [A303331(n) for n in range(1,N+1)]
# _Bert Dobbelaere_, May 01 2018
```
