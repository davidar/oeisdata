# Prime numbers whose digits can be permuted in multiple ways to yield primes\.
https://oeis.org/A318295
## JSON
```JSON
[103, 107, 113, 131, 137, 149, 157, 163, 167, 173, 179, 197, 199, 307, 311, 317, 337, 359, 373, 379, 389, 397, 419, 491, 571, 593, 613, 617, 631, 701, 709, 719, 733, 739, 751, 761, 839, 907, 919, 937, 941, 953, 971, 983, 991, 1009, 1013, 1019, 1021, 1031, 1033]
```
## Maple
```Maple
filter:= proc(n) local L,Lp,t,i,m,x;
  if not isprime(n) then return false fi;
  L:= convert(n,base,10);
  m:= nops(L);
  Lp:= combinat:-permute(L);
  t:= 1;
  for i from 1 to nops(Lp) do
    if Lp[i]=L then next fi;
    x:= add(Lp[i][j]*10^(j-1),j=1..m);
    if isprime(x) then
      t:= t+1;
      if t = 3 then return true fi;
    fi
  od;
  false
end proc:
select(filter, [seq(i,i=11..2000,2)]); # _Robert Israel_, Sep 06 2018
```
## Mathematica
```Mathematica
Select[Prime[Range[200]], Count[PrimeQ[Map[FromDigits, Permutations[IntegerDigits[#]]]], True] > 2 &] (* _Alonso del Arte_, Aug 24 2018 *)
```
```Mathematica
Select[Prime[Range[200]],Count[FromDigits/@Rest[Permutations[IntegerDigits[#]]],_?PrimeQ]>1&] (* _Harvey P. Dale_, Sep 25 2024 *)
```
## Python
```Python
from itertools import *
nmax=1000
def is_prime(num):
    if num == 0 or num == 1: return(0)
    for k in range(2, num):
       if (num % k) == 0:
           return(0)
    return(1)
ris = ""
for i in range(nmax):
    f=0
    lf=[]
    if is_prime(i):
       for p in permutations(str(i), len(str(i))):
            k=int(''.join(p))
            if k!=i and is_prime(k):
                if k not in lf:
                    f+=1
                    lf.append(k)
                if f>1:
                    ris = ris+str(i)+","
                    break
print(ris)
```
