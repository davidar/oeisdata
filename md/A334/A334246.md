# A triple of positive integers \(n,p,k\) is admissible if there exist at least two different multisets of k positive integers, \{x\_1,x\_2,\.\.\.,x\_k\} and \{y\_1,y\_2,\.\.\.,y\_k\}, such that x\_1\+x\_2\+\.\.\.\+x\_k \= y\_1\+y\_2\+\.\.\.\+y\_k \= n and x\_1x\_2\.\.\.x\_k \= y\_1y\_2\.\.\.y\_k \= p\. For each n, let A\(n\) \= \{\(p,k\):\(n,p,k\) is admissible for some k\}; then  a\(n\) \= \|A\(n\)\|\.
https://oeis.org/A334246
## JSON
```JSON
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 5, 7, 13, 20, 29, 44, 66, 90, 129, 174, 232, 306, 406, 520, 675, 851, 1068, 1329, 1640, 2001, 2460, 2989, 3615, 4342, 5202, 6204, 7381, 8697, 10256, 12042, 14069, 16435, 19090, 22141, 25607, 29534]
```
## Python
```Python
from collections import Counter
from functools import reduce
def partitions(n, I=1):
    yield (n,)
    for i in range(I, n//2 + 1):
        for p in partitions(n-i, i):
            yield (i,) + p
def p(i): #ret partitions of i, sorted by part number and product of parts
    return sorted(
        [
            (
                len(p),
                reduce(
                    (lambda x, y: x * y), p)
            )
            for p in partitions(i)
        ]
    )
def a(p_list): #returns number of pairs appearing more than once
    return len([x for x,y in Counter(p_list).most_common() if y > 1])
print(a(p(i))) # Will print the value of a(i)
```
