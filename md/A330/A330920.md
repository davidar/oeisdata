# Number of steps required to reach 1 for repeated applications of the Collatz\-inspired function f\(n\) \= 6\*n\+5\-\(n mod 5\), or \-1 if 1 is never reached\.
https://oeis.org/A330920
## JSON
```JSON
[0, 7, 5, 3, 1, 12, 31, 10, 29, 8, 27, 8, 8, 25, 6, 6, 23, 19, 19, 4, 21, 17, 17, 36, 2, 19, 15, 15, 34, 13, 129, 17, 13, 13, 32, 30, 32, 127, 15, 11, 11, 13, 144, 28, 30, 125, 13, 30, 13, 9, 11, 142, 26, 11, 28, 123, 11, 28, 11, 9, 140, 9, 140, 24, 9, 9, 28, 121]
```
## Python
```Python
def f(n, d):
    """
    A Collatz-like function.
    When d == 2 this becomes '3x+1' problem exactly.
    """
    r = n % d
    if r == 0:
        return n // d
    else:
        # Produce a larger number that is divisible by d.
        return (d + 1) * n + d - r
def steps(n, d):
    """
    Return the number of steps needed to reach 1, or -1 if a 1 is never reached.
    """
    count = 0
    seen = set([1])
    x = n
    # Loop until a cycle is detected.
    while x not in seen:
        seen.add(x)
        x = f(x, d)
        count += 1
    if x == 1:
        return count
    else:
        # There was a cycle
        return -1
# Create a bunch of terms for d=5
S = [steps(x, d=5) for x in range(1, 1000)]
print(S)
```
