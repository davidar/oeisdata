# Numbers k such that k and k^2 use only the digits 0, 1, 2 and 3\.
https://oeis.org/A136809
## JSON
```JSON
[0, 1, 10, 11, 100, 101, 110, 111, 1000, 1001, 1010, 1011, 1100, 1101, 1110, 10000, 10001, 10010, 10011, 10100, 10101, 10110, 10111, 11000, 11001, 11010, 11100, 11101, 100000, 100001, 100010, 100011, 100100, 100101, 100110, 100111, 101000, 101001, 101010, 101011, 101100, 101110, 110000, 110001, 110010, 110100, 110101, 111000, 111001, 111010]
```
## Mathematica
```Mathematica
Select[Range[0,200000],And@@(ContainsAll[{0,1,2,3},Union@IntegerDigits@#]&/@{#,#^2})&] (* _Giorgos Kalogeropoulos_, May 21 2021 *)
```
```Mathematica
With[{c={0,1,2,3}},Select[FromDigits/@Tuples[c,6],SubsetQ[c,IntegerDigits[ #^2]]&]] (* _Harvey P. Dale_, Jun 01 2021 *)
```
## PARI
```PARI
select( {is_A136809(n,o(n)=vecmax(digits(n))<4)=o(n^2)&&o(n)}, [fromdigits(binary(n))|n<-[0..99]]) \\ _M. F. Hasler_, Nov 03 2020
```
## Python
```Python
from itertools import count, islice
def agen(only="0123"):
    digset, valid = set(only), set(only)
    for e in count(1):
        found, newvalid = set(), set()
        for tstr in valid:
            t = int(tstr)
            if (tstr == "0" or tstr[0] != "0") and set(str(t**2)) <= digset:
                found.add(t)
            for d in digset:
                dtstr = d + tstr
                dt = int(dtstr)
                remstr = str(dt**2)[-e:]
                if set(remstr) <= digset:
                    newvalid.add(dtstr)
        valid = newvalid
        yield from sorted(found)
print(list(islice(agen(), 50))) # _Michael S. Branicky_, Jul 07 2022
```
