# a\(n\) is the number of \(2n\+1\)\-digit palindromic primes that undulate\.
https://oeis.org/A057332
## JSON
```JSON
[4, 15, 52, 210, 1007, 5156, 25571, 133293, 727082, 3874464, 21072166, 117829671, 654556778]
```
## Python
```Python
from sympy import isprime
from itertools import product
def sign(n): return (n > 0) - (n < 0)
def unds(n):
  s = str(n)
  if len(s) == 1: return True
  signs = set(sign(int(s[i-1]) - int(s[i])) for i in range(1, len(s), 2))
  if len(signs) > 1: return False
  if len(s) % 2 == 0: return signs == {1} or signs == {-1}
  return sign(int(s[-1]) - int(s[-2])) in signs - {0}
def candidate_pals(n): # of length 2n + 1
  if n == 0: yield from [2, 3, 5, 7]; return # one-digit primes
  for rightbutend in product("0123456789", repeat=n-1):
    rightbutend = "".join(rightbutend)
    for end in "1379": # multi-digit primes must end in 1, 3, 7, or 9
      left = end + rightbutend[::-1]
      for mid in "0123456789": yield int(left + mid + rightbutend + end)
def a(n): return sum(1 for p in candidate_pals(n) if unds(p) and isprime(p))
print([a(n) for n in range(6)]) # _Michael S. Branicky_, Apr 15 2021
```
```Python
from sympy import isprime
def f(w,dir):
    if dir == 1:
        for s in w:
            for t in range(int(s[-1])+1,10):
                yield s+str(t)
    else:
        for s in w:
            for t in range(0,int(s[-1])):
                yield s+str(t)
def A057332(n):
    c = 0
    for d in '123456789':
        x = d
        for i in range(1,n+1):
            x = f(x,(-1)**i)
        c += sum(1 for p in x if isprime(int(p+p[-2::-1])))
        if n > 0:
            y = d
            for i in range(1,n+1):
                y = f(y,(-1)**(i+1))
            c += sum(1 for p in y if isprime(int(p+p[-2::-1])))
    return c # _Chai Wah Wu_, Apr 25 2021
```
