# Numbers n such that the result of n multiplied by the reversal of n can be split into two numbers a and b of equal length \(if the length is odd a leading zero is allowed\), where a \+ b equals n \(b can also have a leading zero\)\.
https://oeis.org/A259316
## JSON
```JSON
[1, 9, 54, 55, 99, 999, 2727, 3222, 7777, 8272, 9999, 12466, 22222, 25912, 39114, 75880, 87777, 87804, 93357, 99999, 124660, 142857, 181818, 185185, 189189, 230769, 231868, 324675, 390313, 412587, 428274, 443926, 503866, 513513, 533169, 568468]
```
## Mathematica
```Mathematica
fQ[n_] := Block[{c, d, len}, c = n FromDigits@ Reverse@ IntegerDigits@ n; d = IntegerDigits@ c; len = Length@ d; If[OddQ@ len, d = PadLeft[d, len + 1]; len++]; n == FromDigits@ Take[d, len/2] + FromDigits@ Take[d, -len/2]]; Select[Range@ 1000000, fQ] (* _Michael De Vlieger_, Jul 20 2015 *)
```
## Python
```Python
def sod(n,m):
    kk = 0
    while n > 0:
        kk= kk+(n%m)
        n =int(n//m)
    return kk
uu=1
for a in range (1,9):
    for n in range (10**(a-1)+1, 10**a):
        y=int(str(n)[::-1])
        ll=int(len(str(n*y))/2+0.5)
        u=sod(n*y,10**ll)
        if n==u:
            print (n)
```
```Python
# for rep2-digit
for f in range (12,98):
    aa=1
    for i in range(1,200):
        aa=10**(2*i)+aa
        c=f*aa
        cc=str(c*int(str(c)[::-1]))
        l=int(len(cc)/2)
        cc1,cc2=int(cc[0:l]),int(cc[l:2*l+1])
        if c==cc1+cc2:
            print (c)
```
