# a\(n\) \= isigma\(n\): sum of infinitary divisors of n\.
https://oeis.org/A049417
## JSON
```JSON
[1, 3, 4, 5, 6, 12, 8, 15, 10, 18, 12, 20, 14, 24, 24, 17, 18, 30, 20, 30, 32, 36, 24, 60, 26, 42, 40, 40, 30, 72, 32, 51, 48, 54, 48, 50, 38, 60, 56, 90, 42, 96, 44, 60, 60, 72, 48, 68, 50, 78, 72, 70, 54, 120, 72, 120, 80, 90, 60, 120, 62, 96, 80, 85, 84, 144, 68, 90]
```
## Maple
```Maple
isidiv := proc(d, n)
    local n2, d2, p, j;
    if n mod d <> 0 then
        return false;
    end if;
    for p in numtheory[factorset](n) do
        padic[ordp](n,p) ;
        n2 := convert(%, base, 2) ;
        padic[ordp](d,p) ;
        d2 := convert(%, base, 2) ;
        for j from 1 to nops(d2) do
            if op(j, n2) = 0 and op(j, d2) <> 0 then
                return false;
            end if;
        end do:
    end do;
    return true;
end proc:
idivisors := proc(n)
    local a, d;
    a := {} ;
    for d in numtheory[divisors](n) do
        if isidiv(d, n) then
            a := a union {d} ;
        end if;
    end do:
    a ;
end proc:
A049417 := proc(n)
    local d;
    add(d, d=idivisors(n)) ;
end proc:
seq(A049417(n),n=1..100) ; # _R. J. Mathar_, Feb 19 2011
```
## Mathematica
```Mathematica
bitty[k_] := Union[Flatten[Outer[Plus, Sequence @@ ({0, #1} & ) /@ Union[2^Range[0, Floor[Log[2, k]]]*Reverse[IntegerDigits[k, 2]]]]]]; Table[Plus@@((Times @@ (First[it]^(#1 /. z -> List)) & ) /@ Flatten[Outer[z, Sequence @@ bitty /@ Last[it = Transpose[FactorInteger[k]]], 1]]), {k, 2, 120}]
```
```Mathematica
(* Second program: *)
```
```Mathematica
a[n_] := If[n == 1, 1, Sort @ Flatten @ Outer[ Times, Sequence @@ (FactorInteger[n] /. {p_, m_Integer} :> p^Select[Range[0, m], BitOr[m, #] == m &])]] // Total;
```
```Mathematica
Array[a, 100] (* _Jean-Fran√ßois Alcover_, Mar 23 2020, after Paul Abbott in A077609 *)
```
## PARI
```PARI
A049417(n) = {my(b, f=factorint(n)); prod(k=1, #f[,2], b = binary(f[k,2]); prod(j=1, #b, if(b[j], 1+f[k,1]^(2^(#b-j)), 1)))} \\ _Andrew Lelechenko_, Apr 22 2014
```
```PARI
isigma(n)=vecprod([vecprod([f[1]^2^k+1|k<-[0..exponent(f[2])], bittest(f[2],k)])|f<-factor(n)~]) \\ _M. F. Hasler_, Oct 20 2022
```
## Haskell
```Haskell
a049417 1 = 1
a049417 n = product $ zipWith f (a027748_row n) (a124010_row n) where
   f p e = product $ zipWith div
           (map (subtract 1 . (p ^)) $
                zipWith (*) a000079_list $ map (+ 1) $ a030308_row e)
           (map (subtract 1 . (p ^)) a000079_list)
-- _Reinhard Zumkeller_, Sep 18 2015
```
## Python
```Python
from math import prod
from sympy import factorint
def A049417(n): return prod(p**(1<<i)+1 for p, e in factorint(n).items() for i, j in enumerate(bin(e)[-1:1:-1]) if j=='1') # _Chai Wah Wu_, Jul 11 2024
```
