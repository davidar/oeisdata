# Number of n\-step self\-avoiding walks on square lattice\.
https://oeis.org/A001411
## JSON
```JSON
[1, 4, 12, 36, 100, 284, 780, 2172, 5916, 16268, 44100, 120292, 324932, 881500, 2374444, 6416596, 17245332, 46466676, 124658732, 335116620, 897697164, 2408806028, 6444560484, 17266613812, 46146397316, 123481354908, 329712786220, 881317491628]
```
## Maple
```Maple
noloop:=X->evalb(nops(X)=nops({op(X)})):
extend:=proc(L) local L1,U,X,res:
   U:=[[1,0],[0,1],[-1,0],[0,-1]]:
   res:=NULL:for X in U do L1:=[op(L),L[nops(L)]+X]:
   if noloop(L1) then res:=res,L1 fi od:
   return(res) end:
walks:={[[0,0]]}: A001411:=1:
to 12 do walks:=map(x->extend(x),walks): A001411:=A001411,nops(walks) od:
[A001411];
# _Robert FERREOL_, Mar 29 2019
```
## Mathematica
```Mathematica
mo=Tuples[{-1,1}, 2]; a[0]=1; a[tg_, p_:{{0,0}}] := Block[{e, mv = Complement[Last[p]+# & /@ mo, p]}, If[tg == 1, Length@mv, Sum[a[tg-1, Append[p, e]], {e, mv}]]]; a /@ Range[0, 10] (* _Giovanni Resta_, May 06 2016 *)
```
## Python
```Python
def add(L,x):
    M=[y for y in L];M.append(x)
    return(M)
plus=lambda L,M : [x+y for x,y in zip(L,M)]
mo=[[1,0],[0,1],[-1,0],[0,-1]]
def a(n,P=[[0,0]]):
    if n==0: return(1)
    mv1=[plus(P[-1],x) for x in mo]
    mv2=[x for x in mv1 if x not in P]
    if n==1: return(len(mv2))
    else: return(sum(a(n-1,add(P,x)) for x in mv2))
[a(n) for n in range(11)]
# _Robert FERREOL_, Nov 30 2018; after the Mathematica program.
```
