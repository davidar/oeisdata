# Triangle read by rows, Bell transform of Bell numbers\.
https://oeis.org/A264428
## JSON
```JSON
[1, 0, 1, 0, 1, 1, 0, 2, 3, 1, 0, 5, 11, 6, 1, 0, 15, 45, 35, 10, 1, 0, 52, 205, 210, 85, 15, 1, 0, 203, 1029, 1330, 700, 175, 21, 1, 0, 877, 5635, 8946, 5845, 1890, 322, 28, 1, 0, 4140, 33387, 63917, 50358, 20055, 4410, 546, 36, 1, 0, 21147, 212535, 484140, 450905, 214515, 57855, 9240, 870, 45, 1]
```
## Maple
```Maple
# Computes sequence in matrix form.
BellMatrix := proc(f, len) local T, A; A := [seq(f(n), n=0..len-2)];
T := proc(n, k) option remember; if k=0 then k^n else
add(binomial(n-1,j-1)*T(n-j,k-1)*A[j], j=1..n-k+1) fi end;
Matrix(len, (n,k)->T(n-1,k-1), shape=triangular[lower]) end:
BellMatrix(n -> combinat:-bell(n), 9); # _Peter Luschny_, Jan 21 2016
# Alternative, using the recurrence of _Peter Bala_:
R := proc(n) option remember; if n = 0 then 1 else
t*add(binomial(n-1,k)*combinat:-bell(k)*R(n-k-1,t),k=0..n-1) fi end:
T_row := n-> seq(coeff(R(n), t, k), k=0..n):
seq(print(T_row(n)),n=0..8); # _Peter Luschny_, Jun 09 2016
```
## Mathematica
```Mathematica
BellMatrix[f_Function|f_Symbol, len_] := With[{t = Array[f, len, 0]}, Table[BellY[n, k, t], {n, 0, len-1}, {k, 0, len-1}]];
```
```Mathematica
rows = 11;
```
```Mathematica
M = BellMatrix[BellB, rows];
```
```Mathematica
Table[M[[n, k]], {n, 1, rows}, {k, 1, n}] // Flatten (* _Jean-Fran√ßois Alcover_, Jan 21 2016, updated Jul 14 2018 *)
```
```Mathematica
With[{r = 8}, Flatten[Table[BellY[n, k, BellB[Range[0, r]]], {n, 0, r}, {k, 0, n}]]] (* _Jan Mangaldan_, May 22 2016 *)
```
## Sage
```Sage
# The functions below are referenced in various other sequences.
def bell_transform(n, a): # partition_based
    row = []
    fn = factorial(n)
    for k in (0..n):
        result = 0
        for p in Partitions(n, length=k):
            factorial_product = 1
            power_factorial_product = 1
            for part, count in p.to_exp_dict().items():
                factorial_product *= factorial(count)
                power_factorial_product *= factorial(part)**count
            coefficient = fn//(factorial_product*power_factorial_product)
            result += coefficient*prod([a[i-1] for i in p])
        row.append(result)
    return row
def bell_matrix(generator, dim):
    G = [generator(k) for k in srange(dim)]
    row = lambda n: bell_transform(n, G)
    return matrix(ZZ, [row(n)+[0]*(dim-n-1) for n in srange(dim)])
def inverse_bell_matrix(generator, dim):
    G = [generator(k) for k in srange(dim)]
    row = lambda n: bell_transform(n, G)
    M = matrix(ZZ, [row(n)+[0]*(dim-n-1) for n in srange(dim)]).inverse()
    return matrix(ZZ, dim, lambda n,k: (-1)^(n-k)*M[n,k])
bell_numbers = [sum(bell_transform(n, [1]*10)) for n in range(11)]
for n in range(11): print(bell_transform(n, bell_numbers))
```
## PARI
```PARI
bell_matrix(f, len) = { my( m = matrix(len, len) );  m[1, 1] = 1;
  for( n = 1, len-1, m[n+1, 2] = f(n-1) );
  for( n = 0, len-1, for( k = 1, n,
     m[n+1, k+1] = sum(j = 1, n-k+1, binomial(n-1,j-1)*m[n-j+1,k]*m[j+1,2]) ));
  return( m )
}
f(n) = polcoeff( sum( k=0, n, prod( i=1, k, x / (1 - i*x)), x^n * O(x)), n);
bell_matrix(f, 9) \\ _Peter Luschny_, Jan 24 2016
```
## Python
```Python
from functools import cache
from math import comb as binomial
def BellMatrix(f, size):
    A = [f(n) for n in range(size - 1)]
    @cache
    def T(n, k):
        if k == 0: return k ** n
        return sum(
            binomial(n - 1, j) * T(n - j - 1, k - 1) * A[j]
            for j in range(n - k + 1) )
    return [[T(n, k) for k in range(n + 1)] for n in range(size)]
@cache
def b(n, k=0): return n < 1 or k*b(n-1, k) + b(n-1, k+1)
print(BellMatrix(b, 9))  # _Peter Luschny_, Jun 14 2022
```
