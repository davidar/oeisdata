# Largest integer which cannot be partitioned using only parts from the set \{perfect powers excluding the n smallest\}\.
https://oeis.org/A264117
## JSON
```JSON
[23, 55, 87, 94, 119, 178, 271, 312, 335, 403, 501, 551, 598, 717, 861, 861, 903, 1022, 1119, 1248, 1463, 1535, 1688, 2031, 2067, 2416, 2535, 2976, 3064, 3164, 3407, 3552, 3552, 4023, 4143, 4416, 4633, 4663, 5424, 5424, 5688, 6000, 6455]
```
## Python
```Python
from copy import *
from math import *
sol ={}
def a(n):
....global sol
....if n in sol:  return sol[n]
....k = n**2 + 100
....yt = sorted(list(set([b**a for a in range(2, 1+int(log(k)/log(2))) for b in range(1, 1+int(k**(1./a)))])))[n:]
....p0 = yt[0]
....if n-1 in sol and n > 28:  p1 = sol[n-1] + 2 * p0
....else: p1 = 7 * p0 + 400
....yt = sorted(list(set([b**a for a in range(2, 1+int(log(p1)/log(2))) for b in range(1, 1+int(p1**(1./a)))])))[n:]
....st = []
....while st != yt:
........st = deepcopy(yt)
........yt = sorted(list(set(yt + [i+j for i in yt for j in yt if i>=j if i+j < p1])))
....d = 0
....f = yt[0] + 1
....t = f
....for i in range(1,len(yt)):
........if yt[i] == f:
............d += 1
............f += 1
............if d == yt[0] + 1:
................yt = yt[:yt.index(t+1)]
................sol[n] = yt.pop() + 1
................return sol[n]
........else:
............t = f
............f = yt[i]+1
............d = 0
```
