# Start with S \= \{\}\. For m \= 0, 1, 2, 3, \.\.\. let u be the binary expansion of m\. If u is not a substring of S, append the minimal number of 0's and 1's to S to remedy this\. Sequence gives S\.
https://oeis.org/A108737
## JSON
```JSON
[0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1]
```
## Python
```Python
from itertools import count, islice, product
def a(): # generator of terms
    S = ""
    for m in count(0):
        Sm = bin(m)[2:]
        if Sm in S: continue
        for i in range(1, len(Sm)+1):
            v = Sm[-i:]
            t = "" if len(v) == len(Sm) else S[-len(Sm)+i:]
            if t+v == Sm: break
        S += v
        yield from list(map(int, v))
print(list(islice(a(), 105))) # _Michael S. Branicky_, Oct 27 2023
```
