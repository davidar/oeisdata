# Undulating alternating primes\.
https://oeis.org/A343590
## JSON
```JSON
[2, 3, 5, 7, 23, 29, 41, 43, 47, 61, 67, 83, 89, 101, 103, 107, 109, 163, 181, 307, 383, 503, 509, 523, 547, 563, 587, 701, 709, 727, 769, 787, 907, 929, 947, 967, 2141, 2143, 2161, 2309, 2503, 2549, 2707, 2729, 2749, 2767, 2903, 2909, 2927, 2969, 4363, 4507, 4523, 4547, 4549, 4703]
```
## Mathematica
```Mathematica
q[n_] := PrimeQ[n] && AllTrue[Differences[Sign @ Differences[(d = IntegerDigits[n])]], # != 0 &] && AllTrue[Differences @ Mod[d, 2], # != 0 &]; Select[Range[5000], q] (* _Amiram Eldar_, Apr 21 2021 *)
```
## Python
```Python
from sympy import sieve
def sign(n): return (n > 0) - (n < 0)
def ok(p):
  if p < 10: return True
  s = str(p)
  t = set(sign(int(s[i])%2-int(s[i-1])%2)*(-1)**i for i in range(1, len(s)))
  t2 = set(sign(int(s[i])-int(s[i-1]))*(-1)**i for i in range(1, len(s)))
  return (t == {1} or t == {-1}) and (t2 == {1} or t2 == {-1})
def aupto(limit): return [p for p in sieve.primerange(1, limit+1) if ok(p)]
print(aupto(4703)) # _Michael S. Branicky_, Apr 21 2021
```
```Python
from sympy import isprime
def f(w,dir):
    if dir == 1:
        for s in w:
            for t in range(int(s[-1])+1,10,2):
                yield s+str(t)
    else:
        for s in w:
            for t in range(1-int(s[-1])%2,int(s[-1]),2):
                yield s+str(t)
A343590_list = []
for l in range(5):
    for d in '123456789':
        x = d
        for i in range(1,l+1):
            x = f(x,(-1)**i)
        A343590_list.extend([int(p) for p in x if isprime(int(p))])
        if l > 0:
            y = d
            for i in range(1,l+1):
                y = f(y,(-1)**(i+1))
            A343590_list.extend([int(p) for p in y if isprime(int(p))]) # _Chai Wah Wu_, Apr 25 2021
```
