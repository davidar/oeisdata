# Length of the preperiodic part of 'Roll and Subtract' trajectory of n\.
https://oeis.org/A343383
## JSON
```JSON
[0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 6, 4, 5, 3, 3, 5, 4, 6, 2, 1, 2, 6, 4, 5, 3, 3, 5, 4, 6, 2, 1, 2, 6, 4, 5, 3, 3, 5, 4, 6, 2, 1, 2, 6, 4, 5, 3, 3, 5, 4, 6, 2, 1, 2, 6, 4, 5, 3, 3, 5, 4, 6, 2, 1, 2, 6, 4, 5, 3, 3, 5, 4, 6, 2, 1, 2, 6, 4, 5, 3, 3, 5, 4, 6]
```
## Mathematica
```Mathematica
Array[Function[w, LengthWhile[w, # != Last[w] &]]@ NestWhileList[Abs[# - FromDigits@ RotateLeft@ IntegerDigits[#]] &, #, Unequal, All] &, 105, 0] (* _Michael De Vlieger_, Apr 13 2021 *)
```
## Python
```Python
def roll(n):
    """ Moves first digit to the back """
    s = str(n)
    return int(s[1:] + s[0])
def backtrack(past, length, offset, dct):
    """ Goes through every value passed and adds it and it's length to the dictionary """
    if length == 0:
        for elem in past:
            dct[elem] = 0
    i = 0
    while length > 0:
        n = past[i]
        dct[n] = length + offset
        i += 1
        length -= 1
    return dct
def a(n, dct):
    past = []
    length = 0
    while (n not in dct):
        past.append(n)
        length += 1
        n = abs(n - roll(n))
        if n in past: # For duplicates
            length = past.index(n)
            dct = backtrack(past, length, 0, dct)
            return dct, length
    offset = dct[n]
    dct = backtrack(past, length, offset, dct)
    length += offset
    return dct, length
dct = {}
sequence = []
i = 1
while i < 1000:
    out = a(i, dct)
    dct = out[0]
    sequence.append(out[1])
    i += 1
```
