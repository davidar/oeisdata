# Consider the sequence of binary words of integers, LSB to MSB S\(k\) \= \( 0; 1; 01; 11; 001; 101; 011; \.\.\. \)\. Start with a\(0\) \= 0, extend this sequence with the minimum number of \[0;1\] such that it contains S\(1\) then S\(2\) and so forth, as sub\-strings with LSB at any a\(n\)\. We extend the sequence as much as required to include S\(k\) first, in the next step we extend until it includes S\(k\+1\) too\.
https://oeis.org/A347198
## JSON
```JSON
[0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1]
```
## MATLAB
```MATLAB
function a = A347198( max_n )
a = 0; m = 1;
    while length(a) < max_n
      b = bitget(m,1:64);
      word = b(1:find(b == 1, 1, 'last' ));
      if isempty(strfind(a, word))
          offset = 0;
          max_o = min(length(word),length(a));
          for o = 1:max_o
              if  isequal(a(end-(o-1):end),word(1:o))
                  offset = o;
              end
          end
          a = [a word(1+offset:end)];
      end
      m = m+1;
    end
end
```
## Python
```Python
from itertools import count, islice
def a(): # generator of terms
    S = ""
    for k in count(0):
        Sk = bin(k)[2:][::-1]
        if Sk in S: continue
        for i in range(1, len(Sk)+1):
            v = Sk[-i:]
            t = "" if len(v) == len(Sk) else S[-len(Sk)+i:]
            if t+v == Sk: break
        S += v
        yield from list(map(int, v))
print(list(islice(a(), 105))) # _Michael S. Branicky_, Oct 27 2023
```
