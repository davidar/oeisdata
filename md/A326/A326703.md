# BII\-numbers of chains of nonempty sets\.
https://oeis.org/A326703
## JSON
```JSON
[0, 1, 2, 4, 5, 6, 8, 16, 17, 24, 32, 34, 40, 64, 65, 66, 68, 69, 70, 72, 80, 81, 88, 96, 98, 104, 128, 256, 257, 384, 512, 514, 640, 1024, 1025, 1026, 1028, 1029, 1030, 1152, 1280, 1281, 1408, 1536, 1538, 1664, 2048, 2056, 2176, 4096, 4097, 4104, 4112, 4113, 4120]
```
## Mathematica
```Mathematica
bpe[n_]:=Join@@Position[Reverse[IntegerDigits[n,2]],1];
```
```Mathematica
stableQ[u_,Q_]:=!Apply[Or,Outer[#1=!=#2&&Q[#1,#2]&,u,u,1],{0,1}];
```
```Mathematica
Select[Range[0,100],stableQ[bpe/@bpe[#],!SubsetQ[#1,#2]&&!SubsetQ[#2,#1]&]&]
```
## Python
```Python
from itertools import chain, count, combinations, islice
from sympy.combinatorics.subsets import ksubsets
def subsets(x):
    for i in range(1,len(x)):
        for j in ksubsets(x,i):
            yield(list(j))
def a_gen(): #generator of terms
    yield 0
    for n in count(1):
        t,v,j = [[]],[],0
        for i in chain.from_iterable(combinations(range(1, n+1), r) for r in range(n+1)):
            if n in i:
                t[j].append([list(i)])
        while n:
            t.append([])
            for i in t[j]:
                if len(i[-1]) > 1:
                    for k in list(subsets(i[-1])):
                        t[j+1].append(i.copy()+[k])
            if len(t[j+1]) < 1:
                break
            j += 1
        for j in chain.from_iterable(t):
            v.append(sum(2**(sum(2**(m-1) for m in k)-1) for k in j))
        yield from sorted(v)
A326703_list = list(islice(a_gen(), 55)) # _John Tyler Rascoe_, Jun 07 2024
```
