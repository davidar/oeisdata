# Number of permutations f of \{1,\.\.\.,n\} with f\(1\) \= 1 such that those k\*f\(k\) \+ 1 \(k \= 1\.\.n\) are n distinct primes\.
https://oeis.org/A356187
## JSON
```JSON
[1, 1, 0, 0, 0, 2, 2, 6, 4, 24, 6, 162, 330, 1428, 1632]
```
## Mathematica
```Mathematica
(* A program to find all the permutations f of {1,...,9} with f(1) = 1 such that U = {k*f(k)+1: k = 1..9} is a set of 9 distinct primes. *)
```
```Mathematica
V[i_]:=V[i]=Part[Permutations[{2,3,4,5,6,7,8,9}],i]
```
```Mathematica
m=0;Do[U={2};Do[p=j*V[i][[j-1]]+1;If[PrimeQ[p],U=Append[U,p]],{j,2,9}];
```
```Mathematica
If[Length[Union[U]]==9,m=m+1;Print[m," ",V[i]," ",U]],{i,1,8!}]
```
## Python
```Python
from itertools import permutations as perm
from itertools import islice
from sympy import isprime
from math import factorial as fact
import collections
def consume(iterator, n=None):
    "Advance the iterator n-steps ahead. If n is None, consume entirely."
    # Use functions that consume iterators at C speed.
    if n is None:
        # feed the entire iterator into a zero-length deque
        collections.deque(iterator, maxlen=0)
    else:
        # advance to the empty slice starting at position n
        next(islice(iterator, n, n), None)
for x in range(2,20):
    mult = range(1,x)
    count = 0
    q = perm(range(1,x))
    for y in q:
        keeppos = 0
        keepflag = False
        if y[0] != 1:#stop when the first digit is not 1
            break
        z = [mult[a] * y[a] + 1 for a in range(x-1)]
        for b in z[0:-2]:
            if not isprime(b):
                keeppos = z.index(b)
                keepflag = True
                break
        if keepflag:#skip ahead to advance the next non-prime term
            consume(q,fact(x-keeppos-2)-1)
        elif len(set(z)) == len(z) and all(isprime(b) for b in set(z)):#no duplicates and all primes
            count += 1
    print(x-1,count)
# _David Consiglio, Jr._, Aug 04 2022
```
