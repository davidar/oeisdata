# Smallest prime such that the n numbers obtained by removing 1 digit on the right are also prime, while no digit can be added on the right to get another prime\.
https://oeis.org/A232125
## JSON
```JSON
[53, 53, 317, 2393, 23333, 373393, 2399333, 23399339, 1979339333, 103997939939, 4099339193933, 145701173999399393, 2744903797739993993333, 52327811119399399313393, 13302806296379339933399333]
```
## PARI
```PARI
a(n) = {n++; v = vector(n); i = 1; ok = 0; until (ok, while ((i>1) && (v[i] == 9), v[i] = 0; i--); if (i == 1, v[i] = nextprime(v[i]+1), v[i] = v[i]+1); curp = sum (j=1, i, v[j]*(10^(i-j))); if (isprime(curp), if (i != n, i++, nbp = 0; for (z=1, 9, if (isprime(10*curp+z), nbp++);); if (nbp == 0, ok = 1);););); sum (j=1, n, v[j]*(10^(n-j)));}
```
## Python
```Python
from sympy import isprime, nextprime
def a(n):
    p, oo = 2, float('inf')
    while True:
        extends, reach, r1 = 0, [str(p)], []
        while len(reach) > 0 and extends <= n:
            minnotext = oo
            for s in reach:
                wasextended = False
                for d in "1379":
                    if isprime(int(s+d)): r1.append(s+d); wasextended = True
                if not wasextended: minnotext = min(minnotext, int(s))
            if extends == n and minnotext < oo: return minnotext
            if len(r1) > 0: extends += 1
            reach, r1 = r1, []
        p = nextprime(p)
for n in range(12): print(a(n), end=", ") # _Michael S. Branicky_, Aug 08 2021
```
