# Table, t, read by antidiagonals: t\(b,e\) is the smallest k such that k\*b^e is a sum of two successive primes\.
https://oeis.org/A180138
## JSON
```JSON
[5, 5, 4, 5, 4, 2, 5, 2, 2, 1, 5, 1, 7, 6, 7, 5, 2, 4, 2, 2, 4, 5, 6, 1, 10, 9, 10, 2, 5, 1, 18, 1, 2, 8, 20, 1, 5, 2, 2, 10, 4, 8, 2, 26, 9, 5, 3, 2, 15, 30, 12, 12, 25, 22, 15, 5, 18, 1, 20, 2, 18, 2, 12, 11, 10, 8, 5, 1, 6, 6, 22, 19, 4, 1, 36, 6, 16, 4, 5, 4, 1, 24, 6, 16, 6, 28, 4, 12, 10, 8, 2]
```
## Mathematica
```Mathematica
t[b_, e_] := Block[{k = 1, hnp = b^e/2}, While[ h = k*hnp; PrimeQ@h || NextPrime[h, -1] + NextPrime@h != 2 h, k++ ]; k]; Table[ t[b - e, e], {b, 2, 14}, {e, 0, b - 2}] // Flatten
```
```Mathematica
(* to find twins other than 2&3 *) gQ[b_, e_, k_] := Block[{h = k*b^e/2}, NextPrime@h - NextPrime[h, -1] < 3 ]; Do[ If[ gQ[b - e, e, k], Print[{b - e, e}]], {b, 2, 143}, {e, 0, b - 2}]
```
## Python
```Python
from sympy import isprime, nextprime, prevprime
def sum2succ(n):
  if n <= 5: return n == 5
  return not isprime(n//2) and n == prevprime(n//2) + nextprime(n//2)
def T(b, e):
  k, powb = 1, b**e
  while not sum2succ(k*powb): k += 1
  return k
def atodiag(maxd): # maxd antidiagonals
  return [T(b-e, e) for b in range(2, maxd+2) for e in range(b-1)]
print(atodiag(13)) # _Michael S. Branicky_, May 05 2021
```
