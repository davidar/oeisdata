# The smallest number such that n or more positive numbers k exist such that a\(n\) \- k \= sopfr\(a\(n\) \+ k\), where sopfr\(m\) is the sum of the primes dividing m, with repetition\.
https://oeis.org/A369355
## JSON
```JSON
[7, 38, 88, 348, 636, 1032, 3828, 3900, 10632, 16428, 16428, 16428, 44652, 533868, 533868, 533868, 533868, 1182432, 5218548, 7741068, 7741068, 7741068, 33764268, 43777068, 67398582, 70249668, 180911982, 180911982, 180911982, 387668532, 387668532, 387668532]
```
## Python
```Python
from sympy import factorint
from functools import cache
from itertools import count, islice
@cache
def sopfr(n): return sum(p*e for p, e in factorint(n).items())
def f(n): return sum(1 for k in range(1, n-1) if n - k == sopfr(n + k))
def agen(): # generator of terms
    adict, n = dict(), 1
    for m in count(2):
        v = f(m)
        if v not in adict: adict[v] = m
        for i in range(n, v+1): yield m; n += 1
print(list(islice(agen(), 12))) # _Michael S. Branicky_, Feb 11 2024
```
## PARI
```PARI
sopf(n) = {
	my(f = factor(n));
	sum(i = 1, #f~, f[i,1]*f[i,2])
}
upto(n) = {
	my(v = vector(n), res = [], u = 2*precprime(n));
	for(i = 2, u,
		c = i-sopf(i);
		if(c%2 == 0 && 1 <= i - c/2 && i - c/2 <= n && c > 0,
			v[i - c/2]++
		);
	);
	for(i = 1, #v,
		if(v[i] > #res,
			res = concat(res, vector(v[i] - #res));
		);
		if(v[i] > 0 && res[v[i]] == 0,
			res[v[i]] = i
		);	
	);
	res
} \\ _David A. Corneth_, Feb 13 2024
```
