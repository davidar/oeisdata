# a\(n\) \= product of parts of the unordered partition encoded with the runlengths of binary expansion of n\.
https://oeis.org/A227184
## JSON
```JSON
[1, 1, 1, 2, 4, 1, 2, 3, 9, 4, 1, 8, 6, 2, 3, 4, 16, 9, 4, 18, 16, 1, 8, 27, 12, 6, 2, 12, 8, 3, 4, 5, 25, 16, 9, 32, 36, 4, 18, 48, 81, 16, 1, 32, 54, 8, 27, 64, 20, 12, 6, 24, 24, 2, 12, 36, 15, 8, 3, 16, 10, 4, 5, 6, 36, 25, 16, 50, 64, 9, 32, 75, 144, 36, 4, 72]
```
## Mathematica
```Mathematica
Table[Function[b, Times @@ Accumulate@ Prepend[If[Length@ b > 1, Rest[b] - 1, {}], First@ b]]@ Map[Length, Split@ Reverse@ IntegerDigits[n, 2]], {n, 0, 75}] // Flatten (* _Michael De Vlieger_, May 09 2017 *)
```
## Scheme
```Scheme
:
(define (A227184 n) (if (zero? n) 1 (apply * (binexp_to_ascpart n))))
(define (binexp_to_ascpart n) (let ((runlist (reverse! (binexp->runcount1list n)))) (PARTSUMS (cons (car runlist) (map -1+ (cdr runlist))))))
(define (binexp->runcount1list n) (if (zero? n) (list) (let loop ((n n) (rc (list)) (count 0) (prev-bit (modulo n 2))) (if (zero? n) (cons count rc) (if (eq? (modulo n 2) prev-bit) (loop (floor->exact (/ n 2)) rc (1+ count) (modulo n 2)) (loop (floor->exact (/ n 2)) (cons count rc) 1 (modulo n 2)))))))
(define (PARTSUMS a) (cdr (reverse! (fold-left (lambda (psums n) (cons (+ n (car psums)) psums)) (list 0) a))))
```
## Python
```Python
def A227184(n):
  '''Product of parts of the unique unordered partition encoded in the run lengths of the binary expansion of n.'''
  p = 1
  b = n%2
  i = 1
  while (n != 0):
    n >>= 1
    if ((n%2) == b): i += 1
    else:
      b = n%2
      p *= i
  return(p)
```
