# Product of lengths of runs of 1\-bits in binary representation of n\.
https://oeis.org/A227349
## JSON
```JSON
[1, 1, 1, 2, 1, 1, 2, 3, 1, 1, 1, 2, 2, 2, 3, 4, 1, 1, 1, 2, 1, 1, 2, 3, 2, 2, 2, 4, 3, 3, 4, 5, 1, 1, 1, 2, 1, 1, 2, 3, 1, 1, 1, 2, 2, 2, 3, 4, 2, 2, 2, 4, 2, 2, 4, 6, 3, 3, 3, 6, 4, 4, 5, 6, 1, 1, 1, 2, 1, 1, 2, 3, 1, 1, 1, 2, 2, 2, 3, 4, 1, 1, 1, 2, 1, 1, 2, 3, 2, 2, 2, 4, 3, 3, 4, 5, 2, 2, 2, 4, 2, 2, 4, 6, 2, 2, 2, 4, 4, 4, 6, 8, 3, 3, 3, 6, 3, 3, 6, 9, 4]
```
## Maple
```Maple
a:= proc(n) local i, m, r; m, r:= n, 1;
      while m>0 do
        while irem(m, 2, 'h')=0 do m:=h od;
        for i from 0 while irem(m, 2, 'h')=1 do m:=h od;
        r:= r*i
      od; r
    end:
seq(a(n), n=0..100);  # _Alois P. Heinz_, Jul 11 2013
ans:=[];
for n from 0 to 100 do lis:=[]; t1:=convert(n, base, 2); L1:=nops(t1); out1:=1; c:=0;
for i from 1 to L1 do
   if out1 = 1 and t1[i] = 1 then out1:=0; c:=c+1;
   elif out1 = 0 and t1[i] = 1 then c:=c+1;
   elif out1 = 1 and t1[i] = 0 then c:=c;
   elif out1 = 0 and t1[i] = 0 then lis:=[c, op(lis)]; out1:=1; c:=0;
   fi;
   if i = L1 and c>0 then lis:=[c, op(lis)]; fi;
                   od:
a:=mul(i, i in lis);
ans:=[op(ans), a];
od:
ans;  # _N. J. A. Sloane_, Sep 05 2014
```
## Mathematica
```Mathematica
onBitRunLenProd[n_] := Times @@ Length /@ Select[Split @ IntegerDigits[n, 2], #[[1]] == 1 & ]; Array[onBitRunLenProd, 100, 0] (* _Jean-FranÃ§ois Alcover_, Mar 02 2016 *)
```
## Python
```Python
from operator import mul
from functools import reduce
from re import split
def A227349(n):
    return reduce(mul, (len(d) for d in split('0+',bin(n)[2:]) if d)) if n > 0 else 1 # _Chai Wah Wu_, Sep 07 2014
```
## Sage
```Sage
# uses[RLT from A246660]
A227349_list = lambda len: RLT(lambda n: n, len)
A227349_list(88) # _Peter Luschny_, Sep 07 2014
```
## Scheme
```Scheme
(define (A227349 n) (apply * (bisect (reverse (binexp->runcount1list n)) (- 1 (modulo n 2)))))
(define (bisect lista parity) (let loop ((lista lista) (i 0) (z (list))) (cond ((null? lista) (reverse! z)) ((eq? i parity) (loop (cdr lista) (modulo (1+ i) 2) (cons (car lista) z))) (else (loop (cdr lista) (modulo (1+ i) 2) z)))))
(define (binexp->runcount1list n) (if (zero? n) (list) (let loop ((n n) (rc (list)) (count 0) (prev-bit (modulo n 2))) (if (zero? n) (cons count rc) (if (eq? (modulo n 2) prev-bit) (loop (floor->exact (/ n 2)) rc (1+ count) (modulo n 2)) (loop (floor->exact (/ n 2)) (cons count rc) 1 (modulo n 2)))))))
```
