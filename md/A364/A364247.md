# Squares visited by the chess king on a spiral\-numbered board, where the king moves to the square with the fewest steps to reach 1 using the 3x\+1 function\. In case of a tie, the king moves to the square with the smallest number\.
https://oeis.org/A364247
## JSON
```JSON
[1, 2, 4, 16, 5, 6, 8, 24, 10, 26, 48, 80, 120, 168, 122, 170, 226, 227, 228, 172, 173, 174, 232, 176, 128, 88, 56, 90, 92, 136, 93, 58, 32, 13, 3, 12, 11, 28, 52, 84, 85, 53, 29, 30, 31, 57, 89, 130, 180, 181, 131, 132, 133, 184, 244, 186, 245, 312, 246, 314]
```
## Python
```Python
class Spiral:
    def __init__(self):
        self.spiral = [[1]]
    def increment(self, increment_size):
        if increment_size == 0:  # Recursion stop condition
            return
        size = len(self.spiral)
        count = size ** 2 + 1
        if size % 2 != 0:
            self.spiral.insert(0, [])
            for i in reversed(range(0, size + 1)):
                self.spiral[i].append(count)
                count += 1
            for _ in range(size):
                self.spiral[0].insert(0, count)
                count += 1
        else:
            self.spiral.append([])
            for i in range(0, size + 1):
                self.spiral[i].insert(0, count)
                count += 1
            for _ in range(size):
                self.spiral[-1].append(count)
                count += 1
        self.increment(increment_size - 1)
    def find_position(self, target):
        for i, row in enumerate(self.spiral):
            for j, element in enumerate(row):
                if element == target:
                    return (i, j)
    def find_king_neighbours(self, target):
        i, j = self.find_position(target)
        neighbours_position = (
            (i - 1, j - 1), (i - 1, j), (i - 1, j + 1),
            (i, j - 1), (i, j + 1),
            (i + 1, j - 1), (i + 1, j), (i + 1, j + 1)
        )
        return [self.spiral[i][j] for i, j in neighbours_position]
def steps(x):
    count = 0
    while x != 1:
        if x % 2 == 0:
            x //= 2
        else:
            x = 3 * x + 1
        count += 1
    return count
def min_steps(lst):
    """Find the value with the minimal amount of steps with the 3x+1 function (the smallest in case of tie)"""
    if len(lst) == 0:
        raise ValueError("Empty list")
    min_steps_seen, min_seed = float("inf"), float("inf")
    for n in lst:
        step = steps(n)
        if step < min_steps_seen or step == min_steps_seen and n < min_seed:
            min_steps_seen = step
            min_seed = n
    return min_seed
spiral = Spiral()
sequence = [1]
count = 1
print(count, 1)
while True:
    count += 1
    spiral.increment(2)
    neighbours = spiral.find_king_neighbours(sequence[-1])
    neighbours = [n for n in neighbours if n not in sequence]
    try:
        next_square = min_steps(neighbours)
    except ValueError:
        print("End of the sequence.")
        break
    sequence.append(next_square)
    print(count, sequence[-1])
```
