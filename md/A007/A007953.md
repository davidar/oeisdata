# Digital sum \(i\.e\., sum of digits\) of n; also called digsum\(n\)\.
https://oeis.org/A007953
## JSON
```JSON
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 8, 9, 10, 11, 12, 13, 14, 15]
```
## Maple
```Maple
A007953 := proc(n) add(d,d=convert(n,base,10)) ; end proc: # _R. J. Mathar_, Mar 17 2011
```
## Mathematica
```Mathematica
Table[Sum[DigitCount[n][[i]] * i, {i, 9}], {n, 50}] (* _Stefan Steinerberger_, Mar 24 2006 *)
```
```Mathematica
Table[Plus @@ IntegerDigits @ n, {n, 0, 87}] (* or *)
```
```Mathematica
Nest[Flatten[# /. a_Integer -> Array[a + # &, 10, 0]] &, {0}, 2] (* _Robert G. Wilson v_, Jul 27 2006 *)
```
```Mathematica
Total/@IntegerDigits[Range[0,90]] (* _Harvey P. Dale_, May 10 2016 *)
```
```Mathematica
DigitSum[Range[0, 100]] (* Requires v. 14 *) (* _Paolo Xausa_, May 17 2024 *)
```
## PARI
```PARI
a(n)=if(n<1, 0, if(n%10, a(n-1)+1, a(n/10))) \\ Recursive, very inefficient. A more efficient recursive variant: a(n)=if(n>9, n=divrem(n, 10); n[2]+a(n[1]), n)
```
```PARI
a(n, b=10)={my(s=(n=divrem(n, b))[2]); while(n[1]>=b, s+=(n=divrem(n[1], b))[2]); s+n[1]} \\ _M. F. Hasler_, Mar 22 2011
```
```PARI
a(n)=sum(i=1, #n=digits(n), n[i]) \\ Twice as fast. Not so nice but faster:
```
```PARI
a(n)=sum(i=1,#n=Vecsmall(Str(n)),n[i])-48*#n \\ - _M. F. Hasler_, May 10 2015
/* Since PARI 2.7, one can also use: a(n)=vecsum(digits(n)), or better: A007953=sumdigits. [Edited and commented by _M. F. Hasler_, Nov 09 2018] */
```
```PARI
a(n) = sumdigits(n); \\ _Altug Alkan_, Apr 19 2018
```
## Haskell
```Haskell
a007953 n | n < 10 = n
          | otherwise = a007953 n' + r where (n',r) = divMod n 10
-- _Reinhard Zumkeller_, Nov 04 2011, Mar 19 2011
```
## Magma
```Magma
[ &+Intseq(n): n in [0..87] ];  // _Bruno Berselli_, May 26 2011
```
## Smalltalk
```Smalltalk
"Recursive version for general bases. Set base = 10 for this sequence."
digitalSum: base
| s |
base = 1 ifTrue: [^self].
(s := self // base) > 0
  ifTrue: [^(s digitalSum: base) + self - (s * base)]
  ifFalse: [^self]
"by _Hieronymus Fischer_, Mar 24 2014"
```
## Python
```Python
def A007953(n):
    return sum(int(d) for d in str(n)) # _Chai Wah Wu_, Sep 03 2014
```
```Python
def a(n): return sum(map(int, str(n))) # _Michael S. Branicky_, May 22 2021
```
## Scala
```Scala
(0 to 99).map(_.toString.map(_.toInt - 48).sum) // _Alonso del Arte_, Sep 15 2019
```
## Swift
```Swift
A007953(n): String(n).compactMap{$0.wholeNumberValue}.reduce(0, +) // _Egor Khmara_, Jun 15 2021
```
