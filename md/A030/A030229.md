# Numbers that are the product of an even number of distinct primes\.
https://oeis.org/A030229
## JSON
```JSON
[1, 6, 10, 14, 15, 21, 22, 26, 33, 34, 35, 38, 39, 46, 51, 55, 57, 58, 62, 65, 69, 74, 77, 82, 85, 86, 87, 91, 93, 94, 95, 106, 111, 115, 118, 119, 122, 123, 129, 133, 134, 141, 142, 143, 145, 146, 155, 158, 159, 161, 166, 177, 178, 183, 185, 187, 194, 201, 202, 203, 205, 206, 209, 210, 213, 214]
```
## Maple
```Maple
a := n -> `if`(numtheory[mobius](n)=1,n,NULL); seq(a(i),i=1..214); # _Peter Luschny_, May 04 2009
with(numtheory); t := [ ]: f := [ ]: for n from 1 to 250 do if mobius(n) = 1 then t := [ op(t), n ] else f := [ op(f), n ]; fi; od: t; # _Wesley Ivan Hurt_, Oct 11 2013
# alternative
A030229 := proc(n)
    option remember;
    local a;
    if n = 1 then
        1;
    else
        for a from procname(n-1)+1 do
            if numtheory[mobius](a) = 1 then
                return a;
            end if;
        end do:
    end if;
end proc:
seq(A030229(n),n=1..40) ; # _R. J. Mathar_, Sep 22 2020
```
## Mathematica
```Mathematica
Select[Range[214], MoebiusMu[#] == 1 &] (* _Jean-FranÃ§ois Alcover_, Oct 04 2011 *)
```
## PARI
```PARI
isA030229(n)= #(n=factor(n)[,2]) % 2 == 0 && (!n || vecmax(n)==1 )
```
```PARI
is(n)=moebius(n)==1 \\ _Charles R Greathouse IV_, Jan 31 2017
for(n=1,500, isA030229(n)&print1(n",")) \\ _M. F. Hasler_
```
## Haskell
```Haskell
import Data.List (elemIndices)
a030229 n = a030229_list !! (n-1)
a030229_list = map (+ 1) $ elemIndices 1 a008683_list
-- _Reinhard Zumkeller_, Dec 27 2012
```
## Python
```Python
from math import isqrt, prod
from sympy import primerange, integer_nthroot, primepi
def A030229(n):
    def g(x,a,b,c,m): yield from (((d,) for d in enumerate(primerange(b+1,isqrt(x//c)+1),a+1)) if m==2 else (((a2,b2),)+d for a2,b2 in enumerate(primerange(b+1,integer_nthroot(x//c,m)[0]+1),a+1) for d in g(x,a2,b2,c*b2,m-1)))
    def f(x): return int(n-1+x-sum(sum(primepi(x//prod(c[1] for c in a))-a[-1][0] for a in g(x,0,1,1,i)) for i in range(2,x.bit_length(),2)))
    kmin, kmax = 0,1
    while f(kmax) > kmax:
        kmax <<= 1
    while kmax-kmin > 1:
        kmid = kmax+kmin>>1
        if f(kmid) <= kmid:
            kmax = kmid
        else:
            kmin = kmid
    return kmax # _Chai Wah Wu_, Aug 29 2024
```
