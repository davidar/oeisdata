# Let d\(1\)<d\(2\)<\.\.\.<d\(q\) denote the divisors of an integer k\. a\(n\) \= k is the smallest k such that the sum of its first n divisors, s \= d\(1\) \+ \.\.\. \+ d\(n\), is also a divisor of k\.
https://oeis.org/A375574
## JSON
```JSON
[1, 6, 6, 28, 28, 24, 126, 234, 224, 360, 504, 980, 990, 1260, 1764, 1680, 840, 1080, 4140, 960, 5760, 4620, 9180, 11088, 8960, 6120, 11880, 25740, 7140, 2520, 2016, 25344, 9720, 48672, 11760, 10920, 15120, 14112, 61740, 55200, 74340, 91800, 8190, 78624, 70200]
```
## Maple
```Maple
with(numtheory):nn:=10^6:T:=array(1..44):i:=0:
for n from 2 to 45 do:
 ii:=1:
  for a from 6 to nn while ii=1
do:
    d:=divisors(a):n0:=nops(d):
     if n0>=n
      then
       s:=sum('d[j]', 'j'=1..n):
       for m from 1 to n0 do:
        if s=d[m]
         then
          ii:=0:printf(`%d %d\n`,n,a):i:=i+1:T[i]:=a:
           else
          fi :
        od :fi:
  od:od:print(T):
```
## PARI
```PARI
\\ See Corneth link
```
## Python
```Python
from sympy import divisors
from itertools import count, islice
def agen(): # generator of terms
    adict, n = dict(), 1
    for k in count(1):
        d = divisors(k)
        if len(d) < n-1: continue
        dset, s = set(d), 0
        for i, di in enumerate(d, 1):
            s += di
            if i >= n and i not in adict and s in dset: adict[i] = k
        while n in adict: yield adict[n]; n += 1
print(list(islice(agen(), 50))) # _Michael S. Branicky_, Aug 20 2024
```
