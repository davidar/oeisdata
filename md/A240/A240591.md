# The smaller of a pair of successive powerful numbers \(A001694\) without any prime number between them\.
https://oeis.org/A240591
## JSON
```JSON
[8, 25, 32, 121, 288, 675, 1331, 1369, 1936, 2187, 2700, 3125, 5324, 6724, 9800, 10800, 12167, 15125, 32761, 39200, 48668, 70225, 79507, 88200, 97336, 107648, 143641, 156800, 212521, 228484, 235224, 280900, 312481, 332928, 456968, 465124, 574564, 674028, 744769, 829921, 830297, 857476, 877952, 940896]
```
## Mathematica
```Mathematica
Select[Partition[Join[{1},Select[Range[10^6],Min@FactorInteger[#][[All, 2]]> 1&]],2,1],PrimePi[#[[1]]]==PrimePi[#[[2]]]&][[All,1]] (* _Harvey P. Dale_, Mar 28 2018 *)
```
## PARI
```PARI
ispowerful(n)={local(h);if(n==1,h=1,h=(vecmin(factor(n)[, 2])>1));return(h)}
nextpowerful(n)={local(k);k=n+1;while(!ispowerful(k),k+=1);return(k)}
{for(i=1,10^6,if(ispowerful(i),if(nextprime(i)>=nextpowerful(i),print1(i, ", "))))}
```
## Python
```Python
from itertools import count, islice
from math import isqrt
from sympy import mobius, integer_nthroot, nextprime
def A240591_gen(): # generator of terms
    def squarefreepi(n): return int(sum(mobius(k)*(n//k**2) for k in range(1, isqrt(n)+1)))
    def bisection(f,kmin=0,kmax=1):
        while f(kmax) > kmax: kmax <<= 1
        while kmax-kmin > 1:
            kmid = kmax+kmin>>1
            if f(kmid) <= kmid:
                kmax = kmid
            else:
                kmin = kmid
        return kmax
    def f(x):
        c, l, j = x-squarefreepi(integer_nthroot(x,3)[0]), 0, isqrt(x)
        while j>1:
            k2 = integer_nthroot(x//j**2,3)[0]+1
            w = squarefreepi(k2-1)
            c -= j*(w-l)
            l, j = w, isqrt(x//k2**3)
        return c+l
    m = 1
    for n in count(2):
        k = bisection(lambda x:f(x)+n,m,m)
        if nextprime(m) > k:
            yield m
        m = k
A240591_list = list(islice(A240591_gen(),30)) # _Chai Wah Wu_, Sep 14 2024
```
