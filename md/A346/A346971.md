# Smallest c which can be split into positive parts a and b with a\+b\=c, such that the divisors of a,b,c cover all numbers up to n\.
https://oeis.org/A346971
## JSON
```JSON
[2, 3, 4, 8, 10, 12, 24, 45, 54, 88, 120, 182, 182, 360, 540, 1326, 1326, 3990, 5040, 5040, 5040, 9282, 9282, 25200, 25200, 65208, 65208, 118800, 118800, 651456, 651456, 651456, 651456, 651456, 651456, 2314200, 2314200, 2314200, 2314200, 16365396, 16365396]
```
## Mathematica
```Mathematica
a[1]=1;a[n_]:=(k=1;While[Length@Select[Union@*Flatten@*Divisors/@(Join[{k},#]&/@Rest@IntegerPartitions[k,2]),SubsetQ[#,Range@n]&]<1,k++];k);Array[a,16] (* _Giorgos Kalogeropoulos_, Aug 13 2021 *)
```
## Python
```Python
from sympy import divisors
from itertools import count
def cond(a, b, c, n):
    return set(divisors(a)+divisors(b)+divisors(c)) >= set(range(1, n+1))
def a(n):
    if n == 1: return 1
    for c in count(1):
        for a in range(1, c//2+1):
            if cond(a, c-a, c, n): return c
print([a(n) for n in range(1, 17)]) # _Michael S. Branicky_, Aug 13 2021
```
```Python
def A346971(n):
    c, nlist = 1, list(range(1,n+1))
    while True:
        mlist = [m for m in nlist if c % m]
        if len(mlist) == 0: return c
        p = max(mlist)
        for a in range(p,c,p):
            for m in mlist:
                if a % m and (c-a) % m:
                    break
            else:
                return c
        c += 1 # _Chai Wah Wu_, Oct 13 2021
```
