# Square array read by descending antidiagonals: T\(n, k\) \= mu^n\(k\) where mu^1\(k\) \= mu\(k\) \= A008683\(k\) and for each n \>\= 1, mu^\(n\+1\)\(k\) is the Dirichlet convolution of mu\(k\) and mu^n\(k\)\.
https://oeis.org/A346148
## JSON
```JSON
[1, -1, 1, -1, -2, 1, 0, -2, -3, 1, -1, 1, -3, -4, 1, 1, -2, 3, -4, -5, 1, -1, 4, -3, 6, -5, -6, 1, 0, -2, 9, -4, 10, -6, -7, 1, 0, 0, -3, 16, -5, 15, -7, -8, 1, 1, 1, -1, -4, 25, -6, 21, -8, -9, 1, -1, 4, 3, -4, -5, 36, -7, 28, -9, -10, 1, 0, -2, 9, 6, -10, -6]
```
## Mathematica
```Mathematica
T[n_, k_] := If[k == 1, 1, Product[(-1)^e Binomial[n, e], {e, FactorInteger[k][[All, 2]]}]];
```
```Mathematica
Table[T[n-k+1, k], {n, 1, 12}, {k, n, 1, -1}] // Flatten (* _Jean-Fran√ßois Alcover_, Sep 13 2021 *)
```
## Python
```Python
from sympy import binomial, primefactors as pf, multiplicity as mult
from math import prod
def T(n, k):
    return prod((-1)**mult(p, k)*binomial(n, mult(p, k)) for p in pf(k))
```
## PARI
```PARI
T(n, k) = my(f=factor(k)); for (k=1, #f~, f[k,1] = binomial(n, f[k,2])*(-1)^f[k,2]; f[k,2]=1); factorback(f); \\ _Michel Marcus_, Aug 21 2021
```
