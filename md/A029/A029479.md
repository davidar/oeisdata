# Numbers k that divide the \(left\) concatenation of all numbers <\= k written in base 10 \(most significant digit on left\)\.
https://oeis.org/A029479
## JSON
```JSON
[1, 3, 9, 19, 27, 41, 103, 147, 189, 441, 567, 711, 6759, 15353, 24441, 59823, 209903, 1430217, 2848851, 2969973, 13358067, 146247471, 289542573, 1891846557, 2388085659, 4489093899, 5345125899, 5455876131, 9843149241]
```
## Mathematica
```Mathematica
b = 10; c = {}; Select[Range[10^4], Divisible[FromDigits[c = Join[IntegerDigits[#, b], c], b], #] &] (* _Robert Price_, Mar 12 2020 *)
```
```Mathematica
Select[Range[134*10^5],Divisible[FromDigits[Flatten[IntegerDigits/@Range[#,1,-1]]],#]&] (* _Harvey P. Dale_, Oct 09 2022 *)
```
## Python
```Python
def concat_mod(base, k, mod):
  total, offset, digits, n1 = 0, 0, 1, 1
  while n1 <= k:
    n2, p = min(n1*base-1, k), n1*base
    # Compute ((p-1)*n2-1)*p**(n2-n1+1)-(n1-1)*p+n1 divided by (p-1)**2.
    # Since (a//b)%mod == (a%(b*mod))//b, compute the numerator mod (p-1)**2*mod.
    tmp = pow(p,n2-n1+1,(p-1)**2*mod)
    tmp = ((p-1)*n2-1)*tmp-(n1-1)*p+n1
    tmp = (tmp%((p-1)**2*mod))//(p-1)**2
    total += tmp*pow(base,offset,mod)
    offset, digits, n1 = offset+digits*(n2-n1+1), digits+1, p
  return total%mod
for k in range(1,10**10):
  if concat_mod(10, k, k) == 0: print(k) # _Jason Yuen_, Jan 14 2024
```
