# The smallest composite number which divides the concatenation of its ascending ordered prime factors, with repetition, when written in base n\.
https://oeis.org/A371641
## JSON
```JSON
[85329, 4, 224675, 4, 1140391, 4, 9, 4, 28749, 4, 841, 4, 9, 4, 239571, 4, 343, 4, 9, 4, 231, 4, 25, 4, 9, 4, 315, 4, 343, 4, 9, 4, 25, 4, 9761637601, 4, 9, 4, 4234329, 4, 715, 4, 9, 4, 609, 4, 49, 4, 9, 4, 195, 4, 25, 4, 9, 4, 1015, 4, 76729, 4, 9, 4, 25, 4, 14332171]
```
## Python
```Python
from itertools import count
from sympy.ntheory import digits
from sympy import factorint, isprime
def fromdigits(d, b):
    n = 0
    for di in d: n *= b; n += di
    return n
def a(n):
    for k in count(4):
        if isprime(k): continue
        sf = []
        for p, e in factorint(k).items():
            sf.extend(e*digits(p, n)[1:])
        if fromdigits(sf, n)%k == 0:
            return k
print([a(n) for n in range(2, 6)]) # _Michael S. Branicky_, Apr 01 2024
```
```Python
from itertools import count
from sympy import factorint, integer_log
def A371641(n):
    for m in count(4):
        f = factorint(m)
        if sum(f.values()) > 1:
            c = 0
            for p in sorted(f):
                a = pow(n,integer_log(p,n)[0]+1,m)
                for _ in range(f[p]):
                    c = (c*a+p)%m
            if not c:
                return m # _Chai Wah Wu_, Apr 11 2024
```
## PARI
```PARI
has(F,n)=my(f=F[2],t); for(i=1,#f~, my(p=f[i,1],d=#digits(p,n),D=n^d); for(j=1,f[i,2], t=D*t+p)); t%F[1]==0
a(k,lim=10^6,startAt=4)=forfactored(n=startAt,lim, if(vecsum(n[2][,2])>1 && has(n,k), return(n[1]))); a(k,2*lim,lim+1) \\ _Charles R Greathouse IV_, Apr 11 2024
```
