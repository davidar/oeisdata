# Numbers p^2\*q, p \> q odd primes such that q does not divide p\-1, and q does not divide p\+1\.
https://oeis.org/A350421
## JSON
```JSON
[245, 845, 847, 1445, 1859, 2023, 2527, 2645, 3179, 3703, 3757, 3971, 4693, 6137, 6727, 6845, 6877, 8993, 9245, 9251, 9583, 10051, 10571, 10933, 11045, 12493, 14045, 14297, 15059, 15463, 15979, 16337, 17797, 18259, 18491, 19343, 19663, 21853, 22103, 22445, 23273]
```
## Mathematica
```Mathematica
q[n_] := Module[{f = FactorInteger[n], p, e}, p = f[[;; , 1]]; e = f[[;; , 2]]; e == {1, 2} && ! Or @@ Divisible[p[[2]] + {-1, 1}, p[[1]]]]; Select[Range[1, 24000, 2], q] (* _Amiram Eldar_, Dec 30 2021 *)
```
## Magma
```Magma
f:=Factorisation; [n:n in [3..24000 ]|#PrimeDivisors(n) eq 2 and  f(n)[1][1] lt f(n)[2][1] and f(n)[1][2] eq 1 and f(n)[2][2] eq 2  and (f(n)[2][1]-1) mod f(n)[1][1] ne 0 and (f(n)[2][1]+1) mod f(n)[1][1] ne 0]; // _Marius A. Burtea_, Dec 30 2021
```
## Python
```Python
from sympy import integer_nthroot, primerange
def aupto(limit):
    aset, maxp = set(), integer_nthroot(limit**2, 3)[0]
    for p in primerange(3, maxp+1):
        pp = p*p
        for q in primerange(1, min(p, limit//pp+1)):
            if (p-1)%q != 0 and (p+1)%q != 0:
                aset.add(pp*q)
    return sorted(aset)
print(aupto(24000)) # _Michael S. Branicky_, Dec 30 2021
```
## PARI
```PARI
isok(m) = my(f=factor(m)); if (f[, 2] == [1, 2]~, my(p=f[2, 1], q=f[1, 1]); ((p-1) % q) && ((p+1) % q)); \\ _Michel Marcus_, Dec 30 2021
```
