# Consider the succession of single digits of the positive integers: 1 2 3 4 5 6 7 8 9 1 0 1 1 1 2 1 3 1 4 1 5 1 6 \.\.\. \(A007376\)\. This sequence is the lexicographically earliest derangement of the positive integers that produces the same succession of digits\.
https://oeis.org/A098067
## JSON
```JSON
[12, 3, 4, 5, 6, 7, 8, 9, 10, 1, 112, 13, 14, 15, 16, 17, 18, 19, 20, 2, 122, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73]
```
## Mathematica
```Mathematica
lim = 80; f[lst_List, k_] := Block[{L = lst, g, a = {}, m = 0}, g[] := {Set[m, First@ FromDigits@ Append[IntegerDigits@ m, First@ #]], Set[L, Last@ #]} &@ TakeDrop[L, 1]; Do[g[]; While[Or[m == Length@ a + 1, First@ L == 0, MemberQ[a, m]], g[]]; AppendTo[a, m]; m = 0, {k}]; a]; f[Flatten@ Map[IntegerDigits, Range@ lim], Floor[lim - 10^(Log10@ lim - 1)]] (* _Michael De Vlieger_, Nov 29 2015, Version 10.2 *)
```
## Perl
```Perl
See Link section.
```
## Python
```Python
from itertools import count
def diggen():
    for k in count(1): yield from list(map(int, str(k)))
def aupton(terms):
    g = diggen()
    alst, aset, _, _, nextd = [12], {12}, next(g), next(g), next(g)
    for n in range(2, terms+1):
        an, nextd = nextd, next(g)
        while an in aset or an == n or nextd == 0:
            an, nextd = int(str(an) + str(nextd)), next(g)
        alst.append(an); aset.add(an)
    return alst
print(aupton(72)) # _Michael S. Branicky_, Dec 03 2021
```
