# Numbers that are products of \(at least two\) consecutive primes\.
https://oeis.org/A097889
## JSON
```JSON
[6, 15, 30, 35, 77, 105, 143, 210, 221, 323, 385, 437, 667, 899, 1001, 1147, 1155, 1517, 1763, 2021, 2310, 2431, 2491, 3127, 3599, 4087, 4199, 4757, 5005, 5183, 5767, 6557, 7387, 7429, 8633, 9797, 10403, 11021, 11663, 12317, 12673, 14351, 15015, 16637, 17017]
```
## Maple
```Maple
isA097889 := proc(n)
    local plist,p,i ;
    plist := sort(convert(numtheory[factorset](n),list)) ;
    if nops(plist) < 2 then
        return false;
    end if;
    for i from 1 to nops(plist) do
        p := op(i,plist) ;
        if modp(n,p^2) = 0 then
            return false;
        end if;
        if i > 1 then
            if nextprime(op(i-1,plist)) <> p then
                return false;
            end if;
        end if;
    end do:
    true;
end proc:
for n from 1 to 1000 do
    if isA097889(n) then
        printf("%d,",n);
    end if;
end do: # _R. J. Mathar_, Jan 12 2016
```
## Mathematica
```Mathematica
a = {}; Do[ AppendTo[a, Apply[ Times, (Prime /@ Partition[ Range[30], n, i]), 1]], {n, 2, 6}, {i, n - 1}]; Take[ Union[ Flatten[ a]], 45] (* _Robert G. Wilson v_, Sep 24 2004 *)
```
## Haskell
```Haskell
import Data.Set (singleton, deleteFindMin, insert)
a097889 n = a097889_list !! (n-1)
a097889_list = f $ singleton (6, 2, 3) where
   f s = y : f (insert (w, p, q') $ insert (w `div` p, a151800 p, q') s')
         where w = y * q'; q' = a151800 q
               ((y, p, q), s') = deleteFindMin s
-- _Reinhard Zumkeller_, May 12 2015, Aug 26 2011
```
## PARI
```PARI
list(lim)=my(v=List(), p, t); for(e=2, log(lim+.5)\log(2), p=1; t=prod(i=1, e-1, prime(i)); forprime(q=prime(e), lim, t*=q/p; if(t>lim, next(2)); listput(v, t); p=nextprime(p+1))); vecsort(Vec(v)) \\ _Charles R Greathouse IV_, Oct 24 2012
```
## Python
```Python
import heapq
from sympy import sieve
sieve.extend(10**6)
primes = list(sieve._list)
def prime(n): return primes[n-1]
def aupton(terms, verbose=False):
    p = prime(1)*prime(2); h = [(p, 1, 2)]; nextcount = 3; alst = []
    while len(alst) < terms:
        (v, s, l) = heapq.heappop(h)
        alst.append(v)
        if verbose: print(f"{v}, [= Prod_{{i = {s}..{l}}} prime(i)]")
        if v >= p:
            p *= prime(nextcount)
            heapq.heappush(h, (p, 1, nextcount))
            nextcount += 1
        v //= prime(s); s += 1; l += 1; v *= prime(l)
        heapq.heappush(h, (v, s, l))
    return alst
print(aupton(45)) # _Michael S. Branicky_, Jun 15 2021
```
