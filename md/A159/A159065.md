# Number of crossings in a regular drawing of the complete bipartite graph K\(n,n\)\.
https://oeis.org/A159065
## JSON
```JSON
[0, 1, 7, 27, 65, 147, 261, 461, 737, 1143, 1637, 2349, 3217, 4401, 5769, 7457, 9433, 11945, 14753, 18235, 22173, 26771, 31801, 37813, 44449, 52161, 60489, 69955, 80289, 92203, 104941, 119493, 135261, 152705, 171205, 191649, 213473, 237877]
```
## Maple
```Maple
A159065 := proc(n)
    local a,b,c ;
    c := 0 ;
    for a from 1 to n-1 do
    for b from 1 to n-1 do
        if igcd(a,b) = 1 then
            c := c+(n-a)*(n-b) ;
            if 2*a< n and 2*b < n then
                c := c-(n-2*a)*(n-2*b) ;
            end if;
        end if;
    end do:
    end do:
    c ;
end proc:
seq(A159065(n),n=1..30); # _R. J. Mathar_, Jul 20 2017
```
## Mathematica
```Mathematica
a[n_] := Module[{x, y, s1 = 0, s2 = 0}, For[x = 1, x <= n-1, x++, For[y = 1, y <= n-1, y++, If[GCD[x, y] == 1, s1 += (n-x)*(n-y); If[2*x <= n-1 && 2*y <= n-1, s2 += (n-2*x)*(n-2*y)]]]]; s1-s2]; Table[a[n], {n, 1, 40}] (* _Jean-FranÃ§ois Alcover_, Jan 10 2014, translated from _Joerg Arndt_'s PARI code *)
```
## Pascal
```Pascal
s1:=0; s2:=0;
for a:=1 to n-1 do
   for b:=1 to n-1 do
      if gcd(a, b)=1 then
      begin
         s1:=s1+(n-a)*(n-b);
         if (2*a<=n-1) and (2*b<=n-1) then
            s2:=s2+(n-2*a)*(n-2*b);
      end;
a:=s1-s2;
```
## PARI
```PARI
a(n) = {
    my(s1=0, s2=0);
    for (x=1, n-1,
        for (y=1, n-1,
            if ( gcd(x, y)==1,
                s1 += (n-x) * (n-y);
                if ( ( 2*x<=n-1) && (2*y<=n-1),
                    s2 += (n-2*x) * (n-2*y); );
             );
        );
    );
    return( s1 - s2 );
}
\\ _Joerg Arndt_, Oct 13 2013
```
## Python
```Python
from math import gcd
def a159065(n):
    c=0
    for a in range(1, n):
        for b in range(1, n):
            if gcd(a, b)==1:
                c+=(n - a)*(n - b)
                if 2*a<n and 2*b<n:c-=(n - 2*a)*(n - 2*b)
    return c
print([a159065(n) for n in range(1, 51)]) # _Indranil Ghosh_, Jul 20 2017
```
```Python
from sympy import totient
def A159065(n): return n-1 if n <= 2 else 2*n-3+3*sum(totient(i)*(n-i)*i for i in range(2,(n+1)//2)) + sum(totient(i)*(n-i)*(2*n-i) for i in range((n+1)//2,n)) # _Chai Wah Wu_, Aug 16 2021
```
