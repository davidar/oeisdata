# Stern's diatomic series type \(\[0,1\], 1\)\.
https://oeis.org/A174980
## JSON
```JSON
[0, 0, 1, 0, 2, 1, 1, 0, 3, 2, 3, 1, 2, 1, 1, 0, 4, 3, 5, 2, 5, 3, 4, 1, 3, 2, 3, 1, 2, 1, 1, 0, 5, 4, 7, 3, 8, 5, 7, 2, 7, 5, 8, 3, 7, 4, 5, 1, 4, 3, 5, 2, 5, 3, 4, 1, 3, 2, 3, 1, 2, 1, 1, 0, 6, 5, 9, 4, 11, 7, 10, 3, 11, 8, 13, 5, 12, 7, 9, 2, 9, 7, 12, 5, 13, 8, 11, 3, 10, 7, 11, 4, 9, 5, 6, 1, 5, 4, 7, 3, 8]
```
## Maple
```Maple
SternDijkstra := proc(L, p, n) local k, i, len, M; len := nops(L); M := L; k := n; while k > 0 do M[1+(k mod len)] := add(M[i], i=1..len); k := iquo(k, len); od; op(p, M) end:
a := n -> SternDijkstra([0,1], 1, n);
```
## Mathematica
```Mathematica
a[0] = 0; a[n_?OddQ] := a[n] = a[(n-1)/2]; a[n_?EvenQ] := a[n] = a[n/2 - 1] + a[n/2] + Boole[ IntegerQ[ Log[2, n/2]]]; Table[a[n], {n, 0, 100}] (* _Jean-FranÃ§ois Alcover_, Jul 26 2013 *)
```
## Sage
```Sage
def A174980(n):
    M = [0, 1]
    for b in n.bits():
        M[b] = M[0] + M[1]
    return M[0]
print([A174980(n) for n in (0..100)]) # _Peter Luschny_, Nov 28 2017
```
## Python
```Python
# Generating the partitions.
def SDBinaryPartition(n):
    def Double(W, T):
        B = []
        for L in W:
            A = [a*2 for a in L]
            if T > 0: A += [1]*T
            B.append(A)
        return B
    if n == 2: return [[2]]
    if n <  4: return []
    h = n // 2
    H = SDBinaryPartition(h)
    B = Double(H, n % 2)
    if n % 2 == 0:
        H = SDBinaryPartition(h - 1)
        if H != []: B += Double(H, 2)
        if (n & (n - 1)) == 0: B.append([2]*h)
    return B
for n in range(25): print([n], SDBinaryPartition(n)) # _Peter Luschny_, Sep 02 2019
```
