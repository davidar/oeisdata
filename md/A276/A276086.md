# Primorial base exp\-function: digits in primorial base representation of n become the exponents of successive prime factors whose product a\(n\) is\.
https://oeis.org/A276086
## JSON
```JSON
[1, 2, 3, 6, 9, 18, 5, 10, 15, 30, 45, 90, 25, 50, 75, 150, 225, 450, 125, 250, 375, 750, 1125, 2250, 625, 1250, 1875, 3750, 5625, 11250, 7, 14, 21, 42, 63, 126, 35, 70, 105, 210, 315, 630, 175, 350, 525, 1050, 1575, 3150, 875, 1750, 2625, 5250, 7875, 15750, 4375, 8750, 13125, 26250, 39375, 78750, 49, 98, 147, 294, 441, 882, 245, 490, 735, 1470, 2205, 4410, 1225, 2450]
```
## Mathematica
```Mathematica
b = MixedRadix[Reverse@ Prime@ Range@ 12]; Table[Function[k, Times @@ Power @@@ # &@ Transpose@ {Prime@ Range@ Length@ k, Reverse@ k}]@ IntegerDigits[n, b], {n, 0, 51}] (* _Michael De Vlieger_, Aug 23 2016, Version 10.2 *)
```
```Mathematica
f[n_] := Block[{a = {{0, n}}}, Do[AppendTo[a, {First@ #, Last@ #} &@ QuotientRemainder[a[[-1, -1]], Times @@ Prime@ Range[# - i]]], {i, 0, #}] &@ NestWhile[# + 1 &, 0, Times @@ Prime@ Range[# + 1] <= n &]; Rest[a][[All, 1]]]; Table[Times @@ Flatten@ MapIndexed[Prime[#2]^#1 &, Reverse@ f@ n], {n, 0, 73}] (* _Michael De Vlieger_, Aug 30 2016, Pre-Version 10 *)
```
```Mathematica
a[n0_] := Module[{m = 1, i = 1, n = n0, p}, While[n > 0, p = Prime[i]; m *= p^Mod[n, p]; n = Quotient[n, p]; i++]; m];
```
```Mathematica
Table[a[n], {n, 0, 100}] (* _Jean-François Alcover_, Dec 01 2021, after _Antti Karttunen_'s Sage code *)
```
## APL
```APL
A276086 ← { P←47 43 41 37 31 29 23 19 17 13 11 7 5 3 2 ⋄ ×/P*¨P⊤⍵ } ⍝ _Antti Karttunen_, Feb 17 2024
```
## PARI
```PARI
A276086(n) = { my(i=0,m=1,pr=1,nextpr); while((n>0),i=i+1; nextpr = prime(i)*pr; if((n%nextpr),m*=(prime(i)^((n%nextpr)/pr));n-=(n%nextpr));pr=nextpr); m; }; \\ _Antti Karttunen_, May 12 2017
```
```PARI
A276086(n) = { my(m=1, p=2); while(n, m *= (p^(n%p)); n = n\p; p = nextprime(1+p)); (m); }; \\ (Better than above one, avoids unnecessary construction of primorials). - _Antti Karttunen_, Oct 14 2019
```
## Scheme
```Scheme
(define (A276086 n) (let loop ((n n) (t 1) (i 1)) (if (zero? n) t (let* ((p (A000040 i)) (d (modulo n p))) (loop (/ (- n d) p) (* t (expt p d)) (+ 1 i))))))
```
```Scheme
(definec (A276086 n) (if (zero? n) 1 (* (expt (A053669 n) (A276088 n)) (A276086 (A276093 n))))) ;; Needs macro definec from http://oeis.org/wiki/Memoization#Scheme
```
```Scheme
(definec (A276086 n) (if (zero? n) 1 (* (A053669 n) (A276086 (- n (A002110 (A276084 n))))))) ;; Needs macro definec from http://oeis.org/wiki/Memoization#Scheme
```
## Python
```Python
from sympy import prime
def a(n):
    i=0
    m=pr=1
    while n>0:
        i+=1
        N=prime(i)*pr
        if n%N!=0:
            m*=(prime(i)**((n%N)/pr))
            n-=n%N
        pr=N
    return m # _Indranil Ghosh_, May 12 2017, after _Antti Karttunen_'s PARI code
```
```Python
from sympy import nextprime
def a(n):
    m, p = 1, 2
    while n > 0:
        n, r = divmod(n, p)
        m *= p**r
        p = nextprime(p)
    return m
print([a(n) for n in range(74)])  # _Peter Luschny_, Apr 20 2024
```
## Sage
```Sage
def A276086(n):
    m=1
    i=1
    while n>0:
        p = sloane.A000040(i)
        m *= (p**(n%p))
        n = floor(n/p)
        i += 1
    return (m)
# _Antti Karttunen_, Oct 14 2019, after _Indranil Ghosh_'s Python code above, and my own leaner PARI code from Oct 14 2019. This avoids unnecessary construction of primorials.
```
