# Lexicographically first sequence of distinct positive integers where all the digits "1" are separated by one digit\.
https://oeis.org/A276103
## JSON
```JSON
[1, 2, 10, 12, 13, 14, 15, 16, 17, 18, 19, 101, 3, 121, 4, 131, 5, 141, 6, 151, 7, 161, 8, 171, 9, 181, 21, 31, 41, 51, 61, 71, 81, 91, 210, 191, 212, 1010, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1210, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1310, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319]
```
## PARI
```PARI
is_A276103(n,t=n%10==1)=!while(n\=10,t==(t=n%10==1)&&return) \\ _M. F. Hasler_, Oct 22 2021
```
```PARI
A276103_upto(n, a=0, N=[0,0])={vector(n, i, N[i=2^(a%10==1)]=a=if( a>2, n=10^bittest( logint( a=N[i], 10)+i, 0); my(d); until( d < 9, a += n*if( 9 > d = a\n % 10, 1 + !d, a > 99*n, n *= 100; -9, a=if( i>1, 2080, 10^4)*n\99; break)); a, a<2, i, 10))} \\ _M. F. Hasler_, Oct 31 2021
```
## Python
```Python
from itertools import product
def eo1(): # generates +ive terms with every other digit 1 and not-1 or v.v.
    yield from range(1, 10)
    digits = 2
    while True:
        for not1s in product("023456789", repeat=digits//2):
            yield(int("1" + "1".join(not1s) + "1"*(digits%2)))
        for first in "23456789":
            for not1s in product("023456789", repeat=(digits-1)//2):
                yield(int("1".join((first,)+not1s) + "1"*(digits%2==0)))
        digits += 1
def aupton(terms):
    alst, aset, astr = [1], {1}, "1"
    kgen = {True: eo1(), False: eo1()}
    for n in range(2, terms+1):
        mustbegin1 = (astr[-1] != "1")
        k = next(kgen[mustbegin1]); sk = str(k)
        while k in aset or ((sk[0] == "1") != mustbegin1):
            k = next(kgen[mustbegin1]); sk = str(k)
        alst.append(k); aset.add(k); astr += sk
    return alst
print(aupton(64)) # _Michael S. Branicky_, Oct 31 2021
```
