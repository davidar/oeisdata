# Number of directed graphs of 2\*n vertices each having an in\-degree and out\-degree of 1 such that the graph specifies a pairwise connected gift exchange\.
https://oeis.org/A322751
## JSON
```JSON
[1, 0, 4, 80, 4704, 436992, 58897920, 10880501760, 2640513576960, 814928486400000, 311763576754667520, 144816978675459686400, 80294888451877031116800, 52385405443881146567884800, 39727727942688305214337843200, 34656123210118214086941474816000]
```
## Python
```Python
from itertools import permutations as perm
def num_connected_by_pairs(assigned, here=0, seen=None):
    seen = (seen, set())[seen is None]
    for proposed in [(here - 1, here), (here, here + 1)][(here % 2) == 0]:
        if proposed not in seen:
            seen.add(proposed)
            num_connected_by_pairs(assigned, assigned[proposed], seen)
    return len(seen)
def valid(assigned, pairs):
    self_give = [assigned[i] == i for i in range(len(assigned))]
    same_pair = [assigned[i] == i + 1 or assigned[i+1] == i for i in range(0, 2*pairs, 2)]
    if pairs == 0 or True in self_give + same_pair:
        return False
    num_connected = [num_connected_by_pairs(assigned, here) for here in range(2, 2*pairs, 2)]
    return min(num_connected) == 2*pairs
print([len([x for x in perm(range(2*pairs)) if valid(x, pairs)]) for pairs in range(0, 6)])
```
## PARI
```PARI
\\ Here B(n) gives A003471 as vector.
B(n)={my(v=vector(n+1)); v[1]=1; for(n=4, n, my(m = 2-n%2); v[n+1] = v[n]*(n-1) + 2*(n-m)*v[n-2*m+1]); v}
seq(n)={my(v=B(2*n)); Vec(serlaplace(1+log(sum(k=0, n, v[1+2*k]*x^k/k!, O(x*x^n)))))} \\ _Andrew Howroyd_, Jan 13 2024
```
