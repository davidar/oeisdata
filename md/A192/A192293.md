# Let sigma\*\_m \(n\) be the result of applying the sum of anti\-divisors m times to n; call n \(m,k\)\-anti\-perfect if sigma\*\_m \(n\) \= k\*n; this sequence gives the \(2,3\)\-anti\-perfect numbers\.
https://oeis.org/A192293
## JSON
```JSON
[32, 98, 2524, 199282, 1336968]
```
## Maple
```Maple
with(numtheory): P:= proc(n) local i,j,k,s,s1; for i from 3 to n do
k:=0; j:=i; while j mod 2 <> 1 do k:=k+1; j:=j/2; od; s:=sigma(2*i+1)+sigma(2*i-1)+sigma(i/2^k)*2^(k+1)-6*i-2;
k:=0; j:=s; while j mod 2 <> 1 do k:=k+1; j:=j/2; od; s1:=sigma(2*s+1)+sigma(2*s-1)+sigma(s/2^k)*2^(k+1)-6*s-2;
if s1/i=3 then print(i); fi; od; end: P(10^9);
```
## Python
```Python
from sympy import divisors
def antidivisors(n):
    return [2*d for d in divisors(n) if n > 2*d and n % (2*d)] + \
        [d for d in divisors(2*n-1) if n > d >=2 and n % d] + \
        [d for d in divisors(2*n+1) if n > d >=2 and n % d]
A192293_list = []
for n in range(1,10**4):
    if 3*n == sum(antidivisors(sum(antidivisors(n)))):
         A192293_list.append(n) # _Chai Wah Wu_, Dec 02 2014
```
