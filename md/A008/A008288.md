# Square array of Delannoy numbers D\(i,j\) \(i \>\= 0, j \>\= 0\) read by antidiagonals\.
https://oeis.org/A008288
## JSON
```JSON
[1, 1, 1, 1, 3, 1, 1, 5, 5, 1, 1, 7, 13, 7, 1, 1, 9, 25, 25, 9, 1, 1, 11, 41, 63, 41, 11, 1, 1, 13, 61, 129, 129, 61, 13, 1, 1, 15, 85, 231, 321, 231, 85, 15, 1, 1, 17, 113, 377, 681, 681, 377, 113, 17, 1, 1, 19, 145, 575, 1289, 1683, 1289, 575, 145, 19, 1, 1, 21, 181, 833, 2241, 3653, 3653]
```
## Maple
```Maple
A008288 := proc(n, k) option remember; if k = 0 then 1 elif n=k then 1 else procname(n-1, k-1) + procname(n-2, k-1) + procname(n-1, k) end if; end proc: seq(seq(A008288(n,k),k=0..n), n=0..10); # triangular indices n and k
P[0]:=1; P[1]:=x+1; for n from 2 to 12 do P[n]:=expand((x+1)*P[n-1]+x*P[n-2]); lprint(P[n]); lprint(seriestolist(series(P[n],x,200))); end do:
```
## Mathematica
```Mathematica
(* Next, A008288 jointly generated with A035607 *)
u[1, x_] := 1; v[1, x_] := 1; z = 16;
u[n_, x_] := x*u[n - 1, x] + v[n - 1, x];
v[n_, x_] := 2 x*u[n - 1, x] + v[n - 1, x];
Table[Expand[u[n, x]], {n, 1, z/2}]
Table[Expand[v[n, x]], {n, 1, z/2}]
cu = Table[CoefficientList[u[n, x], x], {n, 1, z}];
TableForm[cu]
Flatten[%]    (* A008288 *)
Table[Expand[v[n, x]], {n, 1, z}]
cv = Table[CoefficientList[v[n, x], x], {n, 1, z}];
TableForm[cv]
Flatten[%]    (* A035607 *)
(* _Clark Kimberling_, Mar 09 2012 *)
d[n_, k_] := Binomial[n+k, k]*Hypergeometric2F1[-k, -n, -n-k, -1]; A008288 = Flatten[Table[d[n-k, k], {n, 0, 12}, {k, 0, n}]] (* _Jean-FranÃ§ois Alcover_, Apr 05 2012, after 3rd formula *)
```
## Haskell
```Haskell
a008288 n k = a008288_tabl !! n !! k
a008288_row n = a008288_tabl !! n
a008288_tabl = map fst $ iterate
    (\(us, vs) -> (vs, zipWith (+) ([0] ++ us ++ [0]) $
                       zipWith (+) ([0] ++ vs) (vs ++ [0]))) ([1], [1, 1])
-- _Reinhard Zumkeller_, Jul 21 2013
```
## Sage
```Sage
for k in range(8):
    a = lambda n: hypergeometric([-n, -k], [1], 2)
    print([simplify(a(n)) for n in range(11)]) # _Peter Luschny_, Nov 19 2014
```
## Python
```Python
from functools import cache
@cache
def delannoy_row(n: int) -> list[int]:
    if n == 0: return [1]
    if n == 1: return [1, 1]
    rov = delannoy_row(n - 2)
    row = delannoy_row(n - 1) + [1]
    for k in range(n - 1, 0, -1):
        row[k] += row[k - 1] + rov[k - 1]
    return row
for n in range(10): print(delannoy_row(n))  # _Peter Luschny_, Jul 30 2023
```
