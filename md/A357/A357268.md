# If n is a power of 2, a\(n\) \= n\. Otherwise, if 2^j is the greatest power of 2 not exceeding n, and if k \= n \- 2^j, then a\(n\) is the smallest m\*a\(k\) which has not occurred already, where m is an odd number\.
https://oeis.org/A357268
## JSON
```JSON
[1, 2, 3, 4, 5, 6, 9, 8, 7, 10, 15, 12, 25, 18, 27, 16, 11, 14, 21, 20, 35, 30, 45, 24, 49, 50, 75, 36, 125, 54, 81, 32, 13, 22, 33, 28, 55, 42, 63, 40, 77, 70, 105, 60, 175, 90, 135, 48, 99, 98, 147, 100, 245, 150, 225, 72, 343, 250, 375, 108, 625, 162, 243, 64, 17]
```
## Mathematica
```Mathematica
nn = 65; m = 1; c[_] = False; Do[Set[{m, k}, {1, n - 2^Floor[Log2[n]]}]; If[k == 0, Set[{a[n], c[n]}, {n, True}], While[Set[t, m a[k]]; Or[m == 1, c[t]], m += 2]; Set[{a[n], c[t]}, {t, True}]], {n, nn}]; Array[a, nn] (* _Michael De Vlieger_, Sep 21 2022 *)
```
## Python
```Python
from sympy import nextprime
from sympy.ntheory import digits
from itertools import count, islice
def b(n): return n - 2**(len(bin(n)[2:]) - 1)
def agen():
    aset, alst = set(), [None]
    for n in count(1):
        k = b(n)
        if k == 0: an = n
        else:
            ak, p = alst[k], 3
            while p*ak in aset: p += 2
            an = p*ak
        yield an; aset.add(an); alst.append(an)
print(list(islice(agen(), 65))) # _Michael S. Branicky_, Sep 21 2022
```
## PARI
```PARI
f(n) = n - 2^(logint(n, 2)); \\ A053645
lista(nn) = {my(va = vector(nn), sa = Set(va)); for (n=1, nn, my(x = f(n)); if (x == 0, va[n] = n, my(k=1); while (setsearch(sa, k*va[x]), k+=2); va[n] = k*va[x];); sa = Set(va);); va;} \\ _Michel Marcus_, Sep 27 2022
```
