# Triangle read by rows\. Convolution triangle of the prime indicator sequence A089026\.
https://oeis.org/A357368
## JSON
```JSON
[1, 0, 1, 0, 2, 1, 0, 3, 4, 1, 0, 1, 10, 6, 1, 0, 5, 14, 21, 8, 1, 0, 1, 23, 47, 36, 10, 1, 0, 7, 28, 90, 108, 55, 12, 1, 0, 1, 49, 147, 258, 205, 78, 14, 1, 0, 1, 46, 249, 520, 595, 346, 105, 16, 1, 0, 1, 75, 360, 978, 1437, 1185, 539, 136, 18, 1]
```
## Maple
```Maple
PMatrix := proc(dim, a) local n, k, m, g, M, A;
   if n = 0 then return [1] fi;
   A := [seq(a(i), i = 1..dim-1)];
   M := Matrix(dim, shape=triangular[lower]); M[1, 1] := 1;
   for m from 2 to dim do
       M[m, m] := M[m - 1, m - 1] * A[1];
       for k from m-1 by -1 to 2 do
           M[m, k] := add(A[i]*M[m-i, k-1], i = 1..m-k+1)
od od; M end:
a := n -> if isprime(n) then n else 1 fi: PMatrix(10, a);
# Alternatively, as the coefficients of row polynomials:
P := proc(n, x, a) option remember; ifelse(n = 0, 1,
    x*add(a(n - k)*P(k, x, a), k = 0..n-1)) end:
Pcoeffs := proc(n, a) seq(coeff(P(n, x, a), x, k), k=0..n) end:
seq(Pcoeffs(n, a), n = 0..9);
# Alternatively, term by term:
T := proc(n, k, a) option remember; # _Alois P. Heinz_ style
    `if`(k=0, `if`(n=0, 1, 0), `if`(k=1, `if`(n=0, 0, a(n)),
    (q->add(T(j, q, a)*T(n-j, k-q, a), j=0..n))(iquo(k, 2)))) end:
seq(seq(T(n, k, a), k=0..n), n=0..9);
```
## Mathematica
```Mathematica
PMatrix[dim_, a_] := Module[{n, k, m, g, M, A}, If[n == 0, Return[1]]; A = Array[a, dim-1]; M = Array[0&, {dim, dim}]; M[[1, 1]] = 1; For[m = 2, m <= dim, m++, M[[m, m]] = M[[m-1, m-1]]*A[[1]]; For[k = m-1, k >= 2, k--, M[[m, k]] = Sum[A[[i]]*M[[m-i, k-1]], {i, 1, m-k+1}]]]; M];
```
```Mathematica
a[n_] :=  If[PrimeQ[n], n, 1];
```
```Mathematica
nmax = 10;
```
```Mathematica
PM = PMatrix[nmax+1, a];
```
```Mathematica
T[n_, k_] := PM[[n+1, k+1]];
```
```Mathematica
Table[T[n, k], {n, 0, nmax}, {k, 0, n}] // Flatten (* _Jean-FranÃ§ois Alcover_, Oct 21 2022 *)
```
## Python
```Python
def ConvTriangle(dim: int, a) -> list[list[int]]:
    if callable(a): # Cache the input sequence.
        A = [a(i) for i in range(1, dim)]
    else:
        A = a
    print("In:", A)
    C = [[0 for k in range(m + 1)] for m in range(dim)]
    C[0][0] = 1
    for m in range(1, dim):
        C[m][m] = C[m - 1][m - 1] * A[0]
        for k in range(m - 1, 0, -1):
            C[m][k] = sum(A[i] * C[m - i - 1][k - 1] for i in range(m - k + 1))
    return C
from sympy import isprime, flatten
def a(n): return n if isprime(n) else 1
print(flatten(ConvTriangle(10, a)))
```
