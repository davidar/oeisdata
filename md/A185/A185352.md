# The "smallest countdown" numbers are the smallest positive integer that cannot be made using the numbers n through 1, in order, using the operations \+, \-, \*, /, and parentheses\.
https://oeis.org/A185352
## JSON
```JSON
[2, 4, 8, 17, 39, 92, 275, 922, 2894, 10843, 35944]
```
## Python
```Python
from fractions import Fraction
def genAllTrees(l):
    if len(l) == 0:
        return
    elif len(l) == 1:
        yield l[0], str(l[0])
    else:
        for middle in range(len(l)):
            for lval, leqn in genAllTrees(l[:middle]):
                for rval, reqn in genAllTrees(l[middle:]):
                    yield lval+rval, ("(" + leqn + " + " + reqn + ")")
                    yield lval-rval, ("(" + leqn + " - " + reqn + ")")
                    yield lval*rval, ("(" + leqn + " * " + reqn + ")")
                    if rval != Fraction(0):
                        yield lval/rval, ("(" + leqn + " / " + reqn + ")")
def findSmallestIntNotPresent(n):
    vals = {}
    for val, eqn in genAllTrees([Fraction(i) for i in range(n, 0, -1)]):
        if val.denominator == 1:
            val = val.numerator
            if val not in vals:
                vals[val] = eqn
    i = 1
    while i in vals:
        i += 1
    return i
for i in range(1, 11):
    print(i, findSmallestIntNotPresent(i))
```
