# Decimal representations of hexadecimal numbers that can be misinterpreted as decimal numbers in scientific E notation\.
https://oeis.org/A262222
## JSON
```JSON
[480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511]
```
## C++
```C++
#include <iostream>
#include <string>
using namespace std;
int main()
{
  int n = 0;                  //integer to check
  char hexRepresentation[12];
  for (int i = 0; i < 100;)   //integers found (first 100)
  {
    sprintf(hexRepresentation, "%x", n);              //get hex representation
    char* foundE = strchr(hexRepresentation, 'e');    //look for letter e
    if (foundE != NULL &&                             //at least one e
    hexRepresentation != foundE &&                    //not the first digit
    strpbrk(hexRepresentation, "abcdef") == foundE && //e is not first alpha
    strlen(foundE) != 1 &&                            //something after the e
    strpbrk(foundE + sizeof(char), "abcdef") == NULL) //no alpha after the e
    {
      cout << n << "\n";    //output n
      i++;                  //discovered an integer
    }
    n++;                    //check next value
  }
}
```
## Python
```Python
from itertools import count,product
# every string of d characters with exactly one 'e' in it, and all the other characters digits 0-9, in ascending lexicographic order
def mids(d):
    if d<1:
        raise Exception("d<1")
    if d==1:
        yield 'e'
        return
    for i in range(0,10):
        for m in mids(d-1):
            yield str(i)+m
    for i in range(10**(d-1)):
        yield 'e'+str(i).zfill(d-1)
def a_generator():
    for d in count(1):
        for start in range(1,10): # for each leading digit 1-9
            for mid in mids(d): # for all possible middles made of d characters, containing exactly one 'e'
                for end in range(10): #for each possible final digit, 0-9
                    s = '{}{}{}'.format(start,''.join(mid),end)
                    i = int(s,16)
                    yield i
a262222 = a_generator()
[next(a262222) for _ in range(48)] # _Christian Perfect_, Oct 20 2015
```
## C
```C
#include <stdbool.h>
#define DIGIT_E 14
bool isA262222(int k)
{
    if (k <= 0 || k % 16 == DIGIT_E) return false;
    bool foundE = false;
    int digit;
    while (k > 0) {
        digit = k % 16;
        if (digit == DIGIT_E) {
            if (foundE) return false;
            foundE = true;
        }
        else if (digit > 9) return false;
        k /= 16;
    }
    return foundE && digit != DIGIT_E;
} // _Eric M. Schmidt_, Sep 28 2023
```
