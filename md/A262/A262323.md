# Lexicographically earliest sequence of distinct terms such that the decimal representations of two consecutive terms overlap\.
https://oeis.org/A262323
## JSON
```JSON
[1, 10, 11, 12, 2, 20, 22, 21, 13, 3, 23, 30, 33, 31, 14, 4, 24, 32, 25, 5, 15, 41, 16, 6, 26, 42, 27, 7, 17, 51, 18, 8, 28, 52, 29, 9, 19, 61, 36, 43, 34, 40, 44, 45, 50, 35, 53, 37, 63, 38, 73, 39, 83, 48, 54, 46, 60, 56, 55, 57, 65, 58, 75, 47, 64, 49, 74]
```
## Haskell
```Haskell
import Data.List (inits, tails, intersect, delete)
a262323 n = a262323_list !! (n-1)
a262323_list = 1 : f "1" (map show [2..]) where
   f xs zss = g zss where
     g (ys:yss) | null (intersect its $ tail $ inits ys) &&
                  null (intersect tis $ init $ tails ys) = g yss
                | otherwise = (read ys :: Int) : f ys (delete ys zss)
     its = init $ tails xs; tis = tail $ inits xs
-- _Reinhard Zumkeller_, Sep 21 2015
```
## Python
```Python
def overlaps(a, b):
  s, t = sorted([str(a), str(b)], key = lambda x: len(x))
  if any(t.startswith(s[i:]) for i in range(len(s))): return True
  return any(t.endswith(s[:i]) for i in range(1, len(s)+1))
def aupto(nn):
  alst, aset = [1], {1}
  for n in range(2, nn+1):
    an = 1
    while True:
      while an in aset: an += 1
      if overlaps(an, alst[-1]): alst.append(an); aset.add(an); break
      an += 1
  return alst
print(aupto(67)) # _Michael S. Branicky_, Jan 10 2021
```
