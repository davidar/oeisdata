# a\(n\) is the number of ways that n square tiles can be formed into two rectangles, such that those rectangles fit orthogonally into the minimal bounding square that can contain n such tiles, without overlap\.
https://oeis.org/A338664
## JSON
```JSON
[0, 1, 1, 1, 2, 2, 2, 1, 1, 4, 2, 4, 2, 2, 1, 2, 4, 4, 4, 4, 3, 2, 2, 1, 2, 6, 5, 6, 2, 7, 2, 3, 2, 2, 1, 3, 6, 6, 6, 5, 4, 6, 4, 2, 3, 2, 2, 1, 3, 8, 4, 10, 4, 6, 3, 9, 2, 4, 2, 3, 2, 2, 1, 4, 5, 10, 6, 6, 8, 4, 4, 9, 4, 2]
```
## Python
```Python
import numpy as np
# This sets the number of terms:
nits = 20
# This list will contain the complete sequence:
seq_entries = []
# i is the index of the term to be calculated:
for i in range(1, nits + 1):
    # This variable counts the rectangle pairs:
    count = 0
    # Calculate the side length of the minimal bounding square:
    bd_sq_side = np.ceil(np.sqrt(i))
    # Looking for pairs of rectangles of sizes a x b and c x d (all integers)
    # such that both can fit orthogonally into the minimal bounding square (integer side length)
    # WLOG suppose that:
    # a is the greatest of a, b, c, d...
    # c >= d
    # if a = c then b >= d
    # a rectangle of size 0 X 0 is not acceptable
    # The longest side length of either rectangle:
    for a in np.arange(1,bd_sq_side + 1):
        # The other side length of the same rectangle:
        for b in np.arange(1,1 + min(a,np.floor(i/a))):
            # Find the remaining area for the other rectangle:
            area_1   = a*b
            rem_area = i - area_1
            # If there is no remaining area, the first rectangle is not valid:
            if rem_area == 0:
                continue
            # The shorter side of the second rectangle:
            for d in np.arange(1,1 + min(a,np.floor(np.sqrt(rem_area)))):
                # The longer side of the second rectangle:
                c = rem_area / d
                # Check that the solution is valid:
                if b + d <= bd_sq_side and c == int(c) and c <= bd_sq_side and c <= a and ((a != c) or (b >= d)):
                    count += 1
    # Add the entry calculated to the list
    seq_entries.append(count)
for an in seq_entries:
    print(an)
```
