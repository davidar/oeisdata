# Triangle read by rows\. The definition is by diagonals\. The r\-th diagonal from the right, for r \>\= 0, is given by b\(0\) \= b\(1\) \= 1; b\(n\+1\) \= Sum\_\{k\=0\.\.n\} binomial\(n\+2,k\+r\)\*a\(k\)\.
https://oeis.org/A121207
## JSON
```JSON
[1, 1, 1, 1, 1, 2, 1, 1, 3, 5, 1, 1, 4, 9, 15, 1, 1, 5, 14, 31, 52, 1, 1, 6, 20, 54, 121, 203, 1, 1, 7, 27, 85, 233, 523, 877, 1, 1, 8, 35, 125, 400, 1101, 2469, 4140, 1, 1, 9, 44, 175, 635, 2046, 5625, 12611, 21147, 1, 1, 10, 54, 236, 952, 3488, 11226, 30846, 69161, 115975]
```
## Maple
```Maple
# This is the Jovovic formula with general index 'd'
# where A040027, A045499, etc. use one explicit integer
# Index n+1 is shifted to n from the original formula.
Gould := proc(n, d) local k;
    if n <= 1 then return 1 else
    return add(binomial(n-1+d, k+d)*Gould(k, d), k=0..n-1);
    fi
end:
# row and col refer to the extrapolated super-table:
# working up to row, not row-1, shows also the Bell numbers
# at the end of each row.
for row from 0 to 13 do
    for col from 0 to row do
       # 'diag' is constant for one of A040027, A045499 etc.
       diag := row - col;
       printf("%4d, ", Gould(col, diag));
    od;
    print();
od; # _R. J. Mathar_
# second Maple program:
T:= proc(n, k) option remember; `if`(k=0, 1,
      add(T(n-j, k-j)*binomial(n-1, j-1), j=1..k))
    end:
seq(seq(T(n, k), k=0..n), n=0..12);  # _Alois P. Heinz_, Jan 08 2018
```
## Mathematica
```Mathematica
g[n_ /; n <= 1, _] := 1; g[n_, d_] := g[n, d] = Sum[ Binomial[n-1+d, k+d]*g[k, d], {k, 0, n-1}]; Flatten[ Table[ diag = row-col; g[col, diag], {row, 0, 13}, {col, 0, row}]] (* _Jean-François Alcover_, Nov 25 2011, after _R. J. Mathar_ *)
```
```Mathematica
T[n_, k_] := T[n, k] = If[k == 0, 1, Sum[T[n-j, k-j] Binomial[n-1, j-1], {j, 1, k}]]; Table[T[n, k], {n, 0, 12}, {k, 0, n}] // Flatten (* _Jean-François Alcover_, Jul 26 2018, after _Alois P. Heinz_ *)
```
## Python
```Python
# Computes the n-th diagonal of the triangle reading from the right.
from itertools import accumulate
def Gould_diag(diag, size):
    if size < 1: return []
    if size == 1: return [1]
    L, accu = [1,1], [1]*diag
    for _ in range(size-2):
        accu = list(accumulate([accu[-1]] + accu))
        L.append(accu[-1])
    return L # _Peter Luschny_, Apr 24 2016
```
## Julia
```Julia
function Gould_diag(diag, size)
    size < 1 && return []
    size == 1 && return [1]
    L = [1, 1]
    accu = ones(BigInt, diag)
    for _ in 1:size-2
        accu = cumsum(vcat(accu[end], accu))
        L = vcat(L, accu[end])
    end
L end # _Peter Luschny_, Mar 30 2022
```
