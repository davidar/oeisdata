# In binary representation: keep the first digit and left\-rotate the others\.
https://oeis.org/A080541
## JSON
```JSON
[1, 2, 3, 4, 6, 5, 7, 8, 10, 12, 14, 9, 11, 13, 15, 16, 18, 20, 22, 24, 26, 28, 30, 17, 19, 21, 23, 25, 27, 29, 31, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 64, 66, 68, 70, 72, 74, 76, 78, 80]
```
## Maple
```Maple
f:= proc(n) local d;
   d:= ilog2(n);
   if n >= 3/2*2^d then 2*n+1-2^(d+1) else 2*n - 2^d fi
end proc:
map(f, [$1..100]); # _Robert Israel_, May 19 2015
```
## Scheme
```Scheme
(define (A080541 n) (if (< n 2) n (A003986bi (A053644 n) (+ (* 2 (A053645 n)) (A079944off2 n))))) ;; A003986bi gives the bitwise OR of its two arguments. See A003986.
;; Where A079944off2 gives the second most significant bit of n. (Cf. A079944):
(define (A079944off2 n) (A000035 (floor->exact (/ n (A072376 n)))))
;; _Antti Karttunen_, May 16 2015
```
## R
```R
maxlevel <- 6 # by choice
a <- 1:3
for(m in 1:maxlevel) for(k in 0:(2^(m-1)-1)){
a[2^(m+1)       + 2*k    ] = 2*a[2^m           + k]
a[2^(m+1)       + 2*k + 1] = 2*a[2^m + 2^(m-1) + k]
a[2^(m+1) + 2^m + 2*k    ] = 2*a[2^m           + k] + 1
a[2^(m+1) + 2^m + 2*k + 1] = 2*a[2^m + 2^(m-1) + k] + 1
}
a
# _Yosu Yurramendi_, Oct 12 2020
```
## Python
```Python
def A080541(n): return ((n&(m:=1<<n.bit_length()-2)-1)<<1)+(m<<1)+bool(m&n) if n > 1 else n  # _Chai Wah Wu_, Jan 22 2023
```
