# Trajectory of 1 under the morphism 1 \-\> 12, 2 \-\> 3, 3 \-\> 1\.
https://oeis.org/A105083
## JSON
```JSON
[1, 2, 3, 1, 1, 2, 1, 2, 3, 1, 2, 3, 1, 1, 2, 3, 1, 1, 2, 1, 2, 3, 1, 1, 2, 1, 2, 3, 1, 2, 3, 1, 1, 2, 1, 2, 3, 1, 2, 3, 1, 1, 2, 3, 1, 1, 2, 1, 2, 3, 1, 2, 3, 1, 1, 2, 3, 1, 1, 2, 1, 2, 3, 1, 1, 2, 1, 2, 3, 1, 2, 3, 1, 1, 2, 3, 1, 1, 2, 1, 2, 3, 1, 1, 2, 1, 2, 3, 1, 2, 3, 1, 1, 2, 1, 2, 3, 1, 2]
```
## Mathematica
```Mathematica
Nest[ Function[ l, {Flatten[(l /. {1 -> {1, 2}, 2 -> {3}, 3 -> {1}})] }], {1}, 12]
```
## Python
```Python
N_TERMS=10000
def a():
  # Index of the current term
  n = 0
  # Stores the place values of the greedy representation of n,
  # minus two since A000930 begins with duplicate ones.
  places = []
  # Edge case: a(0)=1.
  yield 0, 1
  while True:
    n += 1
    # Add A000930(2+0)=1 to the representation of n
    places.append(0)
    # Apply carryover rule for as long as necessary:
    # if places contains n+2 and n,
    # both terms are replaced by n+3.
    while len(places) > 1 and places[-2] <= places[-1]+2:
      places.pop()
      places[-1] += 1
    # Look at the smallest term to decide a(n)
    an = 1 if places[-1] > 1 else places[-1]+2
    yield n, an
# Asymptotic behavior is O(log(n)*log(log(n))) memory
# and O(n) time to generate the first n terms,
# although a term may take as long as O(log(n)).
for n, an in a():
  print(n, an)
  if (n >= N_TERMS):
    break
# _Aresh Pourkavoos_, Jan 26 2021
```
