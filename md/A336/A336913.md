# Image of n under the 3^x\+1 map, which is a variation of the 3x\+1 \(Collatz\) map\.
https://oeis.org/A336913
## JSON
```JSON
[4, 1, 28, 2, 244, 2, 2188, 3, 19684, 3, 177148, 3, 1594324, 3, 14348908, 4, 129140164, 4, 1162261468, 4, 10460353204, 4, 94143178828, 4, 847288609444, 4, 7625597484988, 4, 68630377364884, 4, 617673396283948, 5, 5559060566555524, 5, 50031545098999708, 5]
```
## Python
```Python
from math import floor, log
def a(n): return 3**n + 1 if n % 2 else int(floor(log(n, 2)))
print([a(n) for n in range(1, 51)])
```
```Python
'''
Program that confirms that 3^x+1 trajectories end with 1.
We avoid the expensive 3^n+1 calculation based on the following:
- 3^n is not a power of two (for n >= 1).
- 3^n+1 is not a power of two (for n > 1) because of the Catalan Conjecture, which was proven in 2002.
- Thus, floor(log2(3^n+1)) == floor(log2(3^n)) == floor(n*log2(3)) for n > 1.
Thanks to Clark R. Lyons for this optimization.
'''
from math import floor, log
log2_of_3 = log(3, 2) # 16 digits after the decimal point.
max_n = 10**15 / 2    # Larger values multiplied by log2_of_3 may have rounding errors.
def check_trajectory(n):
    while n > 1:
        if n % 2 == 0:
            n = int(floor(log(n, 2)))
        else:
            if n > max_n:
                raise ValueError(str(n) + " is too large to be multiplied by log2_of_3")
            n = int(floor(n * log2_of_3))
n = 1
while n <= 1000000000:
    check_trajectory(n)
    n += 1
```
