# Number of n\-node graphs with two connected components\.
https://oeis.org/A275165
## JSON
```JSON
[1, 1, 2, 3, 9, 29, 142, 998, 12145, 273400, 11991377, 1018707920, 165078860715, 50500999728875, 29053989521340327, 31426435300576595334, 64000986599534312456052, 245935832697890955733422940, 1787577661113111145804012336114, 24637809007125076355873926288686728]
```
## Mathematica
```Mathematica
terms = 20;
```
```Mathematica
mob[m_, n_] := If[Mod[m, n] == 0, MoebiusMu[m/n], 0];
```
```Mathematica
EULERi[b_] := Module[{a, c, i, d}, c = {}; For[i = 1, i <= Length[b], i++,c = Append[c, i*b[[i]] - Sum[c[[d]]*b[[i - d]], {d, 1, i - 1}]]]; a = {}; For[i = 1, i <= Length[b], i++, a = Append[a, (1/i)*Sum[mob[i, d]*c[[d]], {d, 1, i}]]]; Return[a]];
```
```Mathematica
permcount[v_] := Module[{m = 1, s = 0, k = 0, t}, For[i = 1, i <= Length[v], i++, t = v[[i]]; k = If[i > 1 && t == v[[i - 1]], k + 1, 1]; m *= t*k; s += t]; s!/m];
```
```Mathematica
edges[v_] := Sum[GCD[v[[i]], v[[j]]], {i, 2, Length[v]}, {j, 1, i - 1}] +
```
```Mathematica
   Total[Quotient[v, 2]];
```
```Mathematica
a88[n_] := Module[{s = 0}, Do[s += permcount[p]*2^edges[p], {p, IntegerPartitions[n]}]; s/n!];
```
```Mathematica
A[x_] = Join[{1}, EULERi[Array[a88, terms]]].(x^Range[0, terms]);
```
```Mathematica
CoefficientList[(A[x]^2 + A[x^2])/2 + O[x]^terms, x] (* _Jean-Fran√ßois Alcover_, May 28 2019, after _Andrew Howroyd_ in A001349 *)
```
## Python
```Python
from functools import lru_cache
from itertools import combinations
from fractions import Fraction
from math import prod, gcd, factorial, comb
from sympy import mobius, divisors
from sympy.utilities.iterables import partitions
def A275165(n):
    @lru_cache(maxsize=None)
    def b(n): return int(sum(Fraction(1<<sum(p[r]*p[s]*gcd(r,s) for r,s in combinations(p.keys(),2))+sum((q>>1)*r+(q*r*(r-1)>>1) for q, r in p.items()),prod(q**r*factorial(r) for q, r in p.items())) for p in partitions(n)))
    @lru_cache(maxsize=None)
    def c(n): return n*b(n)-sum(c(k)*b(n-k) for k in range(1,n))
    @lru_cache(maxsize=None)
    def d(n): return sum(mobius(n//d)*c(d) for d in divisors(n,generator=True))//n if n else 1
    return sum(d(i)*d(n-i) for i in range(n+1>>1)) + (0 if n&1 else comb(d(n>>1)+1,2)) # _Chai Wah Wu_, Jul 03 2024
```
