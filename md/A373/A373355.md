# Triangle read by rows: T\(n, k\) \= \[n \- k \+ 1 \|\| k\] where \[n \|\| k\] is defined below\. Ways in which two primes can relate to each other modulo quadratic residue\.
https://oeis.org/A373355
## JSON
```JSON
[1, 2, 3, 2, 1, 3, 1, 0, 0, 1, 2, 2, 1, 3, 3, 2, 3, 0, 0, 2, 3, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 2, 3, 0, 0, 3, 1, 2, 0, 0, 1, 0, 0, 3, 1, 2, 3, 1, 0, 0, 0, 0, 1, 2, 3, 1, 0, 0, 3, 0, 1, 0, 2, 0, 0, 1, 2, 2, 1, 2, 3, 1, 1, 2, 3, 1, 3, 3, 1, 1, 1, 1, 2, 0, 1, 0, 3, 1, 1, 1, 1]
```
## Maple
```Maple
QRP := proc(n, k) local QR, p, q, a, b;
   QR := (a, n) -> NumberTheory:-QuadraticResidue(a, n);
   p := ithprime(n); q := ithprime(k);
   a := QR(p, q); b := QR(q, p);
   if a = -1 and b = -1 then return 0 fi;
   if a =  1 and b =  1 then return 1 fi;
   if a =  1 and b = -1 then return 2 fi;
   if a = -1 and b =  1 then return 3 fi;
end: for n from 1 to 12 do lprint([n], seq(QRP(n-k+1, k), k = 1..n)) od;
```
## Mathematica
```Mathematica
QR[n_, k_] := Module[{x, y}, If[Reduce[x^2 == n + k*y, {x, y}, Integers] =!= False, 1, -1]];
```
```Mathematica
QRS[n_, k_] := Module[{p = Prime[n], q = Prime[k], a, b}, a = QR[p, q]; b = QR[q, p]; Which[
```
```Mathematica
      a == -1 && b == -1, 0,
```
```Mathematica
      a == 1 && b == 1, 1,
```
```Mathematica
      a == 1 && b == -1, 2,
```
```Mathematica
      a == -1 && b == 1, 3]];
```
```Mathematica
Table[QRS[n - k + 1, k], {n, 1, 13}, {k, 1, n}] // Flatten (* _Jean-Fran√ßois Alcover_, Oct 08 2024, after Maple program *)
```
## Python
```Python
from sympy.ntheory import is_quad_residue, prime
def QR(n, k): return is_quad_residue(n, k)
def QRS(n, k):
    p = prime(n); q = prime(k)
    a = QR(p, q); b = QR(q, p)
    if not a and not b: return 0
    if a and b: return 1
    if a and not b: return 2
    if not a and b: return 3
def T(n, k): return QRS(n - k + 1, k)
for n in range(1, 13): print([n], [T(n, k) for k in range(1, n + 1)])
```
