# Triangle read by rows: T\(n, k\) \= \[n \- k \+ 1 \| k\] where \[n \| k\] is defined below\.
https://oeis.org/A373354
## JSON
```JSON
[1, 1, 1, 1, 1, 1, 1, 2, 3, 1, 1, 2, 1, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 0, 1, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 3, 1, 2, 3, 3, 1, 1, 2, 0, 3, 2, 3, 2, 0, 3, 1, 1, 2, 2, 1, 0, 1, 0, 1, 3, 3, 1, 1, 2, 2, 1, 0, 2, 3, 0, 1, 3, 3, 1, 1, 2, 3, 3, 2, 0, 1, 0, 3, 2, 2, 3, 1]
```
## Maple
```Maple
QRS := proc(n, k) local QR, p, q, a, b;
   QR := (a, n) -> NumberTheory:-QuadraticResidue(a, n);
   a := QR(n, k); b := QR(k, n);
   if a = -1 and b = -1 then return 0 fi;
   if a =  1 and b =  1 then return 1 fi;
   if a =  1 and b = -1 then return 2 fi;
   if a = -1 and b =  1 then return 3 fi;
end: for n from 1 to 12 do lprint([n], seq(QRS(n-k+1, k), k = 1..n)) od;
```
## Mathematica
```Mathematica
QR[n_, k_] := Module[{x, y}, If[Reduce[x^2 == n + k*y, {x, y}, Integers] =!= False, 1, -1]];
```
```Mathematica
QRS[n_, k_] := With[{a = QR[n, k], b = QR[k, n]}, Which[
```
```Mathematica
   a == -1 && b == -1, 0,
```
```Mathematica
   a == 1 && b == 1, 1,
```
```Mathematica
   a == 1 && b == -1, 2,
```
```Mathematica
   a == -1 && b == 1, 3]];
```
```Mathematica
Table[QRS[n - k + 1, k], {n, 1, 13}, {k, 1, n}] // Flatten (* _Jean-Fran√ßois Alcover_, Oct 08 2024 *)
```
## Python
```Python
from sympy.ntheory import is_quad_residue
def QR(n, k): return is_quad_residue(n, k)
def QRS(n, k):
    a = QR(n, k); b = QR(k, n)
    if not a and not b: return 0
    if a and b: return 1
    if a and not b: return 2
    if not a and b: return 3
def T(n, k): return QRS(n - k + 1, k)
for n in range(1, 13): print([n], [T(n, k) for k in range(1, n + 1)])
```
