# Inverse Euler transform of the number of divisors function A000005\.
https://oeis.org/A320779
## JSON
```JSON
[1, 1, 0, 0, -1, 1, -1, 0, 1, -1, 0, 1, -1, -1, 2, 1, -2, -2, 2, 3, -4, 0, 3, -3, 3, -2, -2, 2, 1, 7, -15, 0, 17, -11, -1, 0, 9, -4, -18, 26, -10, -10, 24, -17, -15, 21, 27, -42, -37, 69, 43, -113, -11, 149, -98, -24, 67, -57, 24, -53, 213, -243, -193, 704]
```
## Maple
```Maple
# The function EulerInvTransform is defined in A358451.
a := EulerInvTransform(n -> ifelse(n=0, 1, NumberTheory:-SumOfDivisors(n, 0))):
seq(a(n), n = 1..64); # _Peter Luschny_, Nov 21 2022
```
## Mathematica
```Mathematica
EulerInvTransform[{}]={};EulerInvTransform[seq_]:=Module[{final={}},For[i=1,i<=Length[seq],i++,AppendTo[final,i*seq[[i]]-Sum[final[[d]]*seq[[i-d]],{d,i-1}]]];
```
```Mathematica
Table[Sum[MoebiusMu[i/d]*final[[d]],{d,Divisors[i]}]/i,{i,Length[seq]}]];
```
```Mathematica
EulerInvTransform[Table[DivisorSigma[0,n],{n,100}]]
```
## Python
```Python
from functools import lru_cache
from sympy import mobius, divisors, divisor_count
def A320779(n):
    @lru_cache(maxsize=None)
    def b(n): return divisor_count(n)
    @lru_cache(maxsize=None)
    def c(n): return n*b(n)-sum(c(k)*b(n-k) for k in range(1,n))
    return sum(mobius(d)*c(n//d) for d in divisors(n,generator=True))//n # _Chai Wah Wu_, Jul 15 2024
```
