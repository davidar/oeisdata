# Irregular triangle read by rows: T\(n,k\) is the number of connected permutation graphs on n vertices with domination number k, with 1 <\= k <\= floor\(n/2\)\.
https://oeis.org/A320583
## JSON
```JSON
[1, 1, 3, 10, 3, 43, 28, 223, 236, 2, 1364, 1842, 62, 9643, 18433, 1015, 2, 77545, 181568, 14146, 84, 699954, 1938199, 189077, 2093, 2]
```
## Python
```Python
import networkx as nx
import math
def permutation(lst):
    if len(lst) == 0:
        return []
    if len(lst) == 1:
        return [lst]
    l = []
    for i in range(len(lst)):
        m = lst[i]
        remLst = lst[:i] + lst[i + 1:]
        for p in permutation(remLst):
            l.append([m] + p)
    return l
def generatePermsOfSizeN(n):
    lst = []
    for i in range(n):
        lst.append(i+1)
    return permutation(lst)
def powersetHelper(A):
    if A == []:
        return [[]]
    a = A[0]
    incomplete_pset = powersetHelper(A[1:])
    rest = []
    for set in incomplete_pset:
        rest.append([a] + set)
    return rest + incomplete_pset
def powerset(A):
    ps = powersetHelper(A)
    ps.sort(key = len)
    return ps
    print(ps)
def countcnctdDomNumbersOnN(n):
    lst=[]
    l=[]
    perms = generatePermsOfSizeN(n)
    for i in range(n):
        lst.append(i+1)
    ps = powerset(lst)
    dic={}
    for perm in perms:
        tempGraph = nx.Graph()
        tempGraph.add_nodes_from(perm)
        for i in range(len(perm)):
            for k in range(i+1, len(perm)):
                if perm[k] < perm[i]:
                    tempGraph.add_edge(perm[i], perm[k])
        if nx.is_connected(tempGraph)==True:
            for p in ps:
                if nx.is_dominating_set(tempGraph,p):
                    dom = len(p)
                    if dom in dic:
                        dic[dom] += 1
                        break
                    else:
                        dic[dom] = 1
                        break
    return dic
```
