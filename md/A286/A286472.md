# Compound filter \(for counting prime gaps\): a\(1\) \= 1, a\(n\) \= 2\*A032742\(n\) \+ \(1 if n is composite and spf\(A032742\(n\)\) \> nextprime\(spf\(n\)\), and 0 otherwise\)\. Here spf is the smallest prime factor, A020639\.
https://oeis.org/A286472
## JSON
```JSON
[1, 2, 2, 4, 2, 6, 2, 8, 6, 11, 2, 12, 2, 15, 10, 16, 2, 18, 2, 20, 15, 23, 2, 24, 10, 27, 18, 28, 2, 30, 2, 32, 23, 35, 14, 36, 2, 39, 27, 40, 2, 42, 2, 44, 30, 47, 2, 48, 14, 51, 35, 52, 2, 54, 23, 56, 39, 59, 2, 60, 2, 63, 42, 64, 27, 66, 2, 68, 47, 71, 2, 72, 2, 75, 50, 76, 22, 78, 2]
```
## Mathematica
```Mathematica
Table[Function[{p, d}, 2 d + If[And[CompositeQ@ n, FactorInteger[d][[1, 1]] > NextPrime[p]], 1, 0] - Boole[n == 1]] @@ {#, n/#} &@ FactorInteger[n][[1, 1]], {n, 98}] (* _Michael De Vlieger_, May 12 2017 *)
```
## Scheme
```Scheme
(define (A286472 n) (if (= 1 n) n (+ (* 2 (A032742 n)) (if (> (A286471 n) 2) 1 0))))
```
## Python
```Python
from sympy import primefactors, divisors, nextprime
def ok(n): return 1 if isprime(n)==0 and min(primefactors(divisors(n)[-2])) > nextprime(min(primefactors(n))) else 0
def a(n): return 1 if n==1 else 2*divisors(n)[-2] + ok(n) # _Indranil Ghosh_, May 12 2017
```
