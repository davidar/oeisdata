# Numbers that are the products of 2 or more consecutive integers\.
https://oeis.org/A045619
## JSON
```JSON
[0, 2, 6, 12, 20, 24, 30, 42, 56, 60, 72, 90, 110, 120, 132, 156, 182, 210, 240, 272, 306, 336, 342, 360, 380, 420, 462, 504, 506, 552, 600, 650, 702, 720, 756, 812, 840, 870, 930, 990, 992, 1056, 1122, 1190, 1260, 1320, 1332, 1406, 1482, 1560, 1640, 1680]
```
## Mathematica
```Mathematica
maxNum = 1700; lst = {}; For[i = 1, i <= Sqrt[maxNum], i++, j = i + 1; prod = i*j; While[prod < maxNum, AppendTo[lst, prod]; j++; prod *= j]]; lst = Union[lst]
```
## Python
```Python
import heapq
from sympy import sieve
def aupton(terms, verbose=False):
    p = 6; h = [(p, 2, 3)]; nextcount = 4; aset = {0, 2}
    while len(aset) < terms:
        (v, s, l) = heapq.heappop(h)
        aset.add(v)
        if verbose: print(f"{v}, [= Prod_{{i = {s}..{l}}} i]")
        if v >= p:
            p *= nextcount
            heapq.heappush(h, (p, 2, nextcount))
            nextcount += 1
        v //= s; s += 1; l += 1; v *= l
        heapq.heappush(h, (v, s, l))
    return sorted(aset)
print(aupton(52)) # _Michael S. Branicky_, Oct 19 2021
```
## PARI
```PARI
list(lim)=my(v=List([0]),P,k=1,t); while(1, k++; P=binomial('n+k-1,k)*k!; if(subst(P,'n,1)>lim, break); for(n=1,lim, t=eval(P); if(t>lim, next(2)); listput(v,t))); Set(v) \\ _Charles R Greathouse IV_, Nov 16 2021
```
