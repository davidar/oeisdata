# Square array A\(n, k\) \= A101080\(k, A003188\(n\+A006068\(k\)\)\), read by descending antidiagonals, where A003188 is the binary Gray code, A006068 is its inverse, and A101080\(x,y\) gives the Hamming distance between binary expansions of x and y\.
https://oeis.org/A268833
## JSON
```JSON
[0, 0, 1, 0, 1, 2, 0, 1, 2, 1, 0, 1, 2, 3, 2, 0, 1, 2, 3, 2, 3, 0, 1, 2, 1, 2, 1, 2, 0, 1, 2, 3, 2, 3, 2, 1, 0, 1, 2, 1, 2, 3, 4, 3, 2, 0, 1, 2, 1, 2, 3, 4, 3, 2, 3, 0, 1, 2, 3, 2, 3, 4, 3, 2, 3, 4, 0, 1, 2, 3, 2, 3, 4, 3, 2, 1, 4, 3, 0, 1, 2, 1, 2, 1, 2, 3, 2, 3, 2, 3, 2, 0, 1, 2, 1, 2, 3, 2, 1, 2, 3, 2, 3, 2, 3, 0, 1, 2, 3, 2, 3, 4, 3, 2, 3, 4, 1, 2, 1, 2]
```
## Mathematica
```Mathematica
A101080[n_, k_]:= DigitCount[BitXor[n, k], 2, 1];A003188[n_]:=BitXor[n, Floor[n/2]]; A006068[n_]:=If[n<2, n, Block[{m=A006068[Floor[n/2]]}, 2m + Mod[Mod[n,2] + Mod[m, 2], 2]]]; a[r_, 0]:= 0; a[0, c_]:=c; a[r_, c_]:= A003188[1 + A006068[a[r - 1, c - 1]]]; A[r_, c_]:=A101080[c, a[r, r + c]]; Table[A[c, r - c], {r, 0, 20}, {c, 0, r}] // Flatten (* _Indranil Ghosh_, Apr 02 2017 *)
```
## Scheme
```Scheme
(define (A268833 n) (A268833bi (A002262 n) (A025581 n)))
(define (A268833bi row col) (A101080bi col (A268820bi row (+ row col))))
```
## PARI
```PARI
b(n) = if(n<1, 0, b(n\2) + n%2);
A101080(n, k) = b(bitxor(n, k));
A003188(n) = bitxor(n, n\2);
A006068(n) = if(n<2, n, {my(m = A006068(n\2)); 2*m + (n%2 + m%2)%2});
A268820(r, c) = if(r==0, c, if(c==0, 0, A003188(1 + A006068(A268820(r - 1, c - 1)))));
A(r, c) = A101080(c, A268820(r, r + c));
for(r=0, 20, for(c=0, r, print1(A(c, r - c),", ");); print();) \\ _Indranil Ghosh_, Apr 02 2017
```
```PARI
up_to = 32895; \\ = binomial(1+256,2)-1.\\ A003188 and A006068 as above.
A268833sq(n, k) = hammingweight(bitxor(n,A003188(k+A006068(n))));
A268833list(up_to) = { my(v = vector(up_to), i=0); for(a=0,oo, for(col=0,a, i++; if(i > up_to, return(v)); v[i] = A268833sq(a-col,col))); (v); };
v268833 = A268833list(1+up_to);
A268833(n) = v268833[1+n]; \\ _Antti Karttunen_, Mar 11 2024
```
## Python
```Python
def A101080(n, k): return bin(n^k)[2:].count("1")
def A003188(n): return n^(n//2)
def A006068(n):
    if n<2: return n
    else:
        m=A006068(n//2)
        return 2*m + (n%2 + m%2)%2
def A268820(r, c): return c if r<1 else 0 if c<1 else A003188(1 + A006068(A268820(r - 1, c - 1)))
def a(r, c): return A101080(c, A268820(r, r + c))
for r in range(21):
    print([a(c, r - c) for c in range(r + 1)]) # _Indranil Ghosh_, Apr 02 2017
```
